<!DOCTYPE html>
    <html>
    <head>
        <meta charset="UTF-8">
        <title>LeetCode&#x5237;&#x9898;&#x7B14;&#x8BB0;</title>
        <style>
/* From extension vscode.markdown-math */
@font-face{font-family:KaTeX_AMS;src:url(fonts/KaTeX_AMS-Regular.woff2) format("woff2"),url(fonts/KaTeX_AMS-Regular.woff) format("woff"),url(fonts/KaTeX_AMS-Regular.ttf) format("truetype");font-weight:400;font-style:normal}@font-face{font-family:KaTeX_Caligraphic;src:url(fonts/KaTeX_Caligraphic-Bold.woff2) format("woff2"),url(fonts/KaTeX_Caligraphic-Bold.woff) format("woff"),url(fonts/KaTeX_Caligraphic-Bold.ttf) format("truetype");font-weight:700;font-style:normal}@font-face{font-family:KaTeX_Caligraphic;src:url(fonts/KaTeX_Caligraphic-Regular.woff2) format("woff2"),url(fonts/KaTeX_Caligraphic-Regular.woff) format("woff"),url(fonts/KaTeX_Caligraphic-Regular.ttf) format("truetype");font-weight:400;font-style:normal}@font-face{font-family:KaTeX_Fraktur;src:url(fonts/KaTeX_Fraktur-Bold.woff2) format("woff2"),url(fonts/KaTeX_Fraktur-Bold.woff) format("woff"),url(fonts/KaTeX_Fraktur-Bold.ttf) format("truetype");font-weight:700;font-style:normal}@font-face{font-family:KaTeX_Fraktur;src:url(fonts/KaTeX_Fraktur-Regular.woff2) format("woff2"),url(fonts/KaTeX_Fraktur-Regular.woff) format("woff"),url(fonts/KaTeX_Fraktur-Regular.ttf) format("truetype");font-weight:400;font-style:normal}@font-face{font-family:KaTeX_Main;src:url(fonts/KaTeX_Main-Bold.woff2) format("woff2"),url(fonts/KaTeX_Main-Bold.woff) format("woff"),url(fonts/KaTeX_Main-Bold.ttf) format("truetype");font-weight:700;font-style:normal}@font-face{font-family:KaTeX_Main;src:url(fonts/KaTeX_Main-BoldItalic.woff2) format("woff2"),url(fonts/KaTeX_Main-BoldItalic.woff) format("woff"),url(fonts/KaTeX_Main-BoldItalic.ttf) format("truetype");font-weight:700;font-style:italic}@font-face{font-family:KaTeX_Main;src:url(fonts/KaTeX_Main-Italic.woff2) format("woff2"),url(fonts/KaTeX_Main-Italic.woff) format("woff"),url(fonts/KaTeX_Main-Italic.ttf) format("truetype");font-weight:400;font-style:italic}@font-face{font-family:KaTeX_Main;src:url(fonts/KaTeX_Main-Regular.woff2) format("woff2"),url(fonts/KaTeX_Main-Regular.woff) format("woff"),url(fonts/KaTeX_Main-Regular.ttf) format("truetype");font-weight:400;font-style:normal}@font-face{font-family:KaTeX_Math;src:url(fonts/KaTeX_Math-BoldItalic.woff2) format("woff2"),url(fonts/KaTeX_Math-BoldItalic.woff) format("woff"),url(fonts/KaTeX_Math-BoldItalic.ttf) format("truetype");font-weight:700;font-style:italic}@font-face{font-family:KaTeX_Math;src:url(fonts/KaTeX_Math-Italic.woff2) format("woff2"),url(fonts/KaTeX_Math-Italic.woff) format("woff"),url(fonts/KaTeX_Math-Italic.ttf) format("truetype");font-weight:400;font-style:italic}@font-face{font-family:"KaTeX_SansSerif";src:url(fonts/KaTeX_SansSerif-Bold.woff2) format("woff2"),url(fonts/KaTeX_SansSerif-Bold.woff) format("woff"),url(fonts/KaTeX_SansSerif-Bold.ttf) format("truetype");font-weight:700;font-style:normal}@font-face{font-family:"KaTeX_SansSerif";src:url(fonts/KaTeX_SansSerif-Italic.woff2) format("woff2"),url(fonts/KaTeX_SansSerif-Italic.woff) format("woff"),url(fonts/KaTeX_SansSerif-Italic.ttf) format("truetype");font-weight:400;font-style:italic}@font-face{font-family:"KaTeX_SansSerif";src:url(fonts/KaTeX_SansSerif-Regular.woff2) format("woff2"),url(fonts/KaTeX_SansSerif-Regular.woff) format("woff"),url(fonts/KaTeX_SansSerif-Regular.ttf) format("truetype");font-weight:400;font-style:normal}@font-face{font-family:KaTeX_Script;src:url(fonts/KaTeX_Script-Regular.woff2) format("woff2"),url(fonts/KaTeX_Script-Regular.woff) format("woff"),url(fonts/KaTeX_Script-Regular.ttf) format("truetype");font-weight:400;font-style:normal}@font-face{font-family:KaTeX_Size1;src:url(fonts/KaTeX_Size1-Regular.woff2) format("woff2"),url(fonts/KaTeX_Size1-Regular.woff) format("woff"),url(fonts/KaTeX_Size1-Regular.ttf) format("truetype");font-weight:400;font-style:normal}@font-face{font-family:KaTeX_Size2;src:url(fonts/KaTeX_Size2-Regular.woff2) format("woff2"),url(fonts/KaTeX_Size2-Regular.woff) format("woff"),url(fonts/KaTeX_Size2-Regular.ttf) format("truetype");font-weight:400;font-style:normal}@font-face{font-family:KaTeX_Size3;src:url(fonts/KaTeX_Size3-Regular.woff2) format("woff2"),url(fonts/KaTeX_Size3-Regular.woff) format("woff"),url(fonts/KaTeX_Size3-Regular.ttf) format("truetype");font-weight:400;font-style:normal}@font-face{font-family:KaTeX_Size4;src:url(fonts/KaTeX_Size4-Regular.woff2) format("woff2"),url(fonts/KaTeX_Size4-Regular.woff) format("woff"),url(fonts/KaTeX_Size4-Regular.ttf) format("truetype");font-weight:400;font-style:normal}@font-face{font-family:KaTeX_Typewriter;src:url(fonts/KaTeX_Typewriter-Regular.woff2) format("woff2"),url(fonts/KaTeX_Typewriter-Regular.woff) format("woff"),url(fonts/KaTeX_Typewriter-Regular.ttf) format("truetype");font-weight:400;font-style:normal}.katex{font:normal 1.21em KaTeX_Main,Times New Roman,serif;line-height:1.2;text-indent:0;text-rendering:auto;border-color:currentColor}.katex *{-ms-high-contrast-adjust:none!important}.katex .katex-version:after{content:"0.13.0"}.katex .katex-mathml{position:absolute;clip:rect(1px,1px,1px,1px);padding:0;border:0;height:1px;width:1px;overflow:hidden}.katex .katex-html>.newline{display:block}.katex .base{position:relative;white-space:nowrap;width:-webkit-min-content;width:-moz-min-content;width:min-content}.katex .base,.katex .strut{display:inline-block}.katex .textbf{font-weight:700}.katex .textit{font-style:italic}.katex .textrm{font-family:KaTeX_Main}.katex .textsf{font-family:KaTeX_SansSerif}.katex .texttt{font-family:KaTeX_Typewriter}.katex .mathnormal{font-family:KaTeX_Math;font-style:italic}.katex .mathit{font-family:KaTeX_Main;font-style:italic}.katex .mathrm{font-style:normal}.katex .mathbf{font-family:KaTeX_Main;font-weight:700}.katex .boldsymbol{font-family:KaTeX_Math;font-weight:700;font-style:italic}.katex .amsrm,.katex .mathbb,.katex .textbb{font-family:KaTeX_AMS}.katex .mathcal{font-family:KaTeX_Caligraphic}.katex .mathfrak,.katex .textfrak{font-family:KaTeX_Fraktur}.katex .mathtt{font-family:KaTeX_Typewriter}.katex .mathscr,.katex .textscr{font-family:KaTeX_Script}.katex .mathsf,.katex .textsf{font-family:KaTeX_SansSerif}.katex .mathboldsf,.katex .textboldsf{font-family:KaTeX_SansSerif;font-weight:700}.katex .mathitsf,.katex .textitsf{font-family:KaTeX_SansSerif;font-style:italic}.katex .mainrm{font-family:KaTeX_Main;font-style:normal}.katex .vlist-t{display:inline-table;table-layout:fixed;border-collapse:collapse}.katex .vlist-r{display:table-row}.katex .vlist{display:table-cell;vertical-align:bottom;position:relative}.katex .vlist>span{display:block;height:0;position:relative}.katex .vlist>span>span{display:inline-block}.katex .vlist>span>.pstrut{overflow:hidden;width:0}.katex .vlist-t2{margin-right:-2px}.katex .vlist-s{display:table-cell;vertical-align:bottom;font-size:1px;width:2px;min-width:2px}.katex .vbox{display:inline-flex;flex-direction:column;align-items:baseline}.katex .hbox{width:100%}.katex .hbox,.katex .thinbox{display:inline-flex;flex-direction:row}.katex .thinbox{width:0;max-width:0}.katex .msupsub{text-align:left}.katex .mfrac>span>span{text-align:center}.katex .mfrac .frac-line{display:inline-block;width:100%;border-bottom-style:solid}.katex .hdashline,.katex .hline,.katex .mfrac .frac-line,.katex .overline .overline-line,.katex .rule,.katex .underline .underline-line{min-height:1px}.katex .mspace{display:inline-block}.katex .clap,.katex .llap,.katex .rlap{width:0;position:relative}.katex .clap>.inner,.katex .llap>.inner,.katex .rlap>.inner{position:absolute}.katex .clap>.fix,.katex .llap>.fix,.katex .rlap>.fix{display:inline-block}.katex .llap>.inner{right:0}.katex .clap>.inner,.katex .rlap>.inner{left:0}.katex .clap>.inner>span{margin-left:-50%;margin-right:50%}.katex .rule{display:inline-block;border:0 solid;position:relative}.katex .hline,.katex .overline .overline-line,.katex .underline .underline-line{display:inline-block;width:100%;border-bottom-style:solid}.katex .hdashline{display:inline-block;width:100%;border-bottom-style:dashed}.katex .sqrt>.root{margin-left:.27777778em;margin-right:-.55555556em}.katex .fontsize-ensurer.reset-size1.size1,.katex .sizing.reset-size1.size1{font-size:1em}.katex .fontsize-ensurer.reset-size1.size2,.katex .sizing.reset-size1.size2{font-size:1.2em}.katex .fontsize-ensurer.reset-size1.size3,.katex .sizing.reset-size1.size3{font-size:1.4em}.katex .fontsize-ensurer.reset-size1.size4,.katex .sizing.reset-size1.size4{font-size:1.6em}.katex .fontsize-ensurer.reset-size1.size5,.katex .sizing.reset-size1.size5{font-size:1.8em}.katex .fontsize-ensurer.reset-size1.size6,.katex .sizing.reset-size1.size6{font-size:2em}.katex .fontsize-ensurer.reset-size1.size7,.katex .sizing.reset-size1.size7{font-size:2.4em}.katex .fontsize-ensurer.reset-size1.size8,.katex .sizing.reset-size1.size8{font-size:2.88em}.katex .fontsize-ensurer.reset-size1.size9,.katex .sizing.reset-size1.size9{font-size:3.456em}.katex .fontsize-ensurer.reset-size1.size10,.katex .sizing.reset-size1.size10{font-size:4.148em}.katex .fontsize-ensurer.reset-size1.size11,.katex .sizing.reset-size1.size11{font-size:4.976em}.katex .fontsize-ensurer.reset-size2.size1,.katex .sizing.reset-size2.size1{font-size:.83333333em}.katex .fontsize-ensurer.reset-size2.size2,.katex .sizing.reset-size2.size2{font-size:1em}.katex .fontsize-ensurer.reset-size2.size3,.katex .sizing.reset-size2.size3{font-size:1.16666667em}.katex .fontsize-ensurer.reset-size2.size4,.katex .sizing.reset-size2.size4{font-size:1.33333333em}.katex .fontsize-ensurer.reset-size2.size5,.katex .sizing.reset-size2.size5{font-size:1.5em}.katex .fontsize-ensurer.reset-size2.size6,.katex .sizing.reset-size2.size6{font-size:1.66666667em}.katex .fontsize-ensurer.reset-size2.size7,.katex .sizing.reset-size2.size7{font-size:2em}.katex .fontsize-ensurer.reset-size2.size8,.katex .sizing.reset-size2.size8{font-size:2.4em}.katex .fontsize-ensurer.reset-size2.size9,.katex .sizing.reset-size2.size9{font-size:2.88em}.katex .fontsize-ensurer.reset-size2.size10,.katex .sizing.reset-size2.size10{font-size:3.45666667em}.katex .fontsize-ensurer.reset-size2.size11,.katex .sizing.reset-size2.size11{font-size:4.14666667em}.katex .fontsize-ensurer.reset-size3.size1,.katex .sizing.reset-size3.size1{font-size:.71428571em}.katex .fontsize-ensurer.reset-size3.size2,.katex .sizing.reset-size3.size2{font-size:.85714286em}.katex .fontsize-ensurer.reset-size3.size3,.katex .sizing.reset-size3.size3{font-size:1em}.katex .fontsize-ensurer.reset-size3.size4,.katex .sizing.reset-size3.size4{font-size:1.14285714em}.katex .fontsize-ensurer.reset-size3.size5,.katex .sizing.reset-size3.size5{font-size:1.28571429em}.katex .fontsize-ensurer.reset-size3.size6,.katex .sizing.reset-size3.size6{font-size:1.42857143em}.katex .fontsize-ensurer.reset-size3.size7,.katex .sizing.reset-size3.size7{font-size:1.71428571em}.katex .fontsize-ensurer.reset-size3.size8,.katex .sizing.reset-size3.size8{font-size:2.05714286em}.katex .fontsize-ensurer.reset-size3.size9,.katex .sizing.reset-size3.size9{font-size:2.46857143em}.katex .fontsize-ensurer.reset-size3.size10,.katex .sizing.reset-size3.size10{font-size:2.96285714em}.katex .fontsize-ensurer.reset-size3.size11,.katex .sizing.reset-size3.size11{font-size:3.55428571em}.katex .fontsize-ensurer.reset-size4.size1,.katex .sizing.reset-size4.size1{font-size:.625em}.katex .fontsize-ensurer.reset-size4.size2,.katex .sizing.reset-size4.size2{font-size:.75em}.katex .fontsize-ensurer.reset-size4.size3,.katex .sizing.reset-size4.size3{font-size:.875em}.katex .fontsize-ensurer.reset-size4.size4,.katex .sizing.reset-size4.size4{font-size:1em}.katex .fontsize-ensurer.reset-size4.size5,.katex .sizing.reset-size4.size5{font-size:1.125em}.katex .fontsize-ensurer.reset-size4.size6,.katex .sizing.reset-size4.size6{font-size:1.25em}.katex .fontsize-ensurer.reset-size4.size7,.katex .sizing.reset-size4.size7{font-size:1.5em}.katex .fontsize-ensurer.reset-size4.size8,.katex .sizing.reset-size4.size8{font-size:1.8em}.katex .fontsize-ensurer.reset-size4.size9,.katex .sizing.reset-size4.size9{font-size:2.16em}.katex .fontsize-ensurer.reset-size4.size10,.katex .sizing.reset-size4.size10{font-size:2.5925em}.katex .fontsize-ensurer.reset-size4.size11,.katex .sizing.reset-size4.size11{font-size:3.11em}.katex .fontsize-ensurer.reset-size5.size1,.katex .sizing.reset-size5.size1{font-size:.55555556em}.katex .fontsize-ensurer.reset-size5.size2,.katex .sizing.reset-size5.size2{font-size:.66666667em}.katex .fontsize-ensurer.reset-size5.size3,.katex .sizing.reset-size5.size3{font-size:.77777778em}.katex .fontsize-ensurer.reset-size5.size4,.katex .sizing.reset-size5.size4{font-size:.88888889em}.katex .fontsize-ensurer.reset-size5.size5,.katex .sizing.reset-size5.size5{font-size:1em}.katex .fontsize-ensurer.reset-size5.size6,.katex .sizing.reset-size5.size6{font-size:1.11111111em}.katex .fontsize-ensurer.reset-size5.size7,.katex .sizing.reset-size5.size7{font-size:1.33333333em}.katex .fontsize-ensurer.reset-size5.size8,.katex .sizing.reset-size5.size8{font-size:1.6em}.katex .fontsize-ensurer.reset-size5.size9,.katex .sizing.reset-size5.size9{font-size:1.92em}.katex .fontsize-ensurer.reset-size5.size10,.katex .sizing.reset-size5.size10{font-size:2.30444444em}.katex .fontsize-ensurer.reset-size5.size11,.katex .sizing.reset-size5.size11{font-size:2.76444444em}.katex .fontsize-ensurer.reset-size6.size1,.katex .sizing.reset-size6.size1{font-size:.5em}.katex .fontsize-ensurer.reset-size6.size2,.katex .sizing.reset-size6.size2{font-size:.6em}.katex .fontsize-ensurer.reset-size6.size3,.katex .sizing.reset-size6.size3{font-size:.7em}.katex .fontsize-ensurer.reset-size6.size4,.katex .sizing.reset-size6.size4{font-size:.8em}.katex .fontsize-ensurer.reset-size6.size5,.katex .sizing.reset-size6.size5{font-size:.9em}.katex .fontsize-ensurer.reset-size6.size6,.katex .sizing.reset-size6.size6{font-size:1em}.katex .fontsize-ensurer.reset-size6.size7,.katex .sizing.reset-size6.size7{font-size:1.2em}.katex .fontsize-ensurer.reset-size6.size8,.katex .sizing.reset-size6.size8{font-size:1.44em}.katex .fontsize-ensurer.reset-size6.size9,.katex .sizing.reset-size6.size9{font-size:1.728em}.katex .fontsize-ensurer.reset-size6.size10,.katex .sizing.reset-size6.size10{font-size:2.074em}.katex .fontsize-ensurer.reset-size6.size11,.katex .sizing.reset-size6.size11{font-size:2.488em}.katex .fontsize-ensurer.reset-size7.size1,.katex .sizing.reset-size7.size1{font-size:.41666667em}.katex .fontsize-ensurer.reset-size7.size2,.katex .sizing.reset-size7.size2{font-size:.5em}.katex .fontsize-ensurer.reset-size7.size3,.katex .sizing.reset-size7.size3{font-size:.58333333em}.katex .fontsize-ensurer.reset-size7.size4,.katex .sizing.reset-size7.size4{font-size:.66666667em}.katex .fontsize-ensurer.reset-size7.size5,.katex .sizing.reset-size7.size5{font-size:.75em}.katex .fontsize-ensurer.reset-size7.size6,.katex .sizing.reset-size7.size6{font-size:.83333333em}.katex .fontsize-ensurer.reset-size7.size7,.katex .sizing.reset-size7.size7{font-size:1em}.katex .fontsize-ensurer.reset-size7.size8,.katex .sizing.reset-size7.size8{font-size:1.2em}.katex .fontsize-ensurer.reset-size7.size9,.katex .sizing.reset-size7.size9{font-size:1.44em}.katex .fontsize-ensurer.reset-size7.size10,.katex .sizing.reset-size7.size10{font-size:1.72833333em}.katex .fontsize-ensurer.reset-size7.size11,.katex .sizing.reset-size7.size11{font-size:2.07333333em}.katex .fontsize-ensurer.reset-size8.size1,.katex .sizing.reset-size8.size1{font-size:.34722222em}.katex .fontsize-ensurer.reset-size8.size2,.katex .sizing.reset-size8.size2{font-size:.41666667em}.katex .fontsize-ensurer.reset-size8.size3,.katex .sizing.reset-size8.size3{font-size:.48611111em}.katex .fontsize-ensurer.reset-size8.size4,.katex .sizing.reset-size8.size4{font-size:.55555556em}.katex .fontsize-ensurer.reset-size8.size5,.katex .sizing.reset-size8.size5{font-size:.625em}.katex .fontsize-ensurer.reset-size8.size6,.katex .sizing.reset-size8.size6{font-size:.69444444em}.katex .fontsize-ensurer.reset-size8.size7,.katex .sizing.reset-size8.size7{font-size:.83333333em}.katex .fontsize-ensurer.reset-size8.size8,.katex .sizing.reset-size8.size8{font-size:1em}.katex .fontsize-ensurer.reset-size8.size9,.katex .sizing.reset-size8.size9{font-size:1.2em}.katex .fontsize-ensurer.reset-size8.size10,.katex .sizing.reset-size8.size10{font-size:1.44027778em}.katex .fontsize-ensurer.reset-size8.size11,.katex .sizing.reset-size8.size11{font-size:1.72777778em}.katex .fontsize-ensurer.reset-size9.size1,.katex .sizing.reset-size9.size1{font-size:.28935185em}.katex .fontsize-ensurer.reset-size9.size2,.katex .sizing.reset-size9.size2{font-size:.34722222em}.katex .fontsize-ensurer.reset-size9.size3,.katex .sizing.reset-size9.size3{font-size:.40509259em}.katex .fontsize-ensurer.reset-size9.size4,.katex .sizing.reset-size9.size4{font-size:.46296296em}.katex .fontsize-ensurer.reset-size9.size5,.katex .sizing.reset-size9.size5{font-size:.52083333em}.katex .fontsize-ensurer.reset-size9.size6,.katex .sizing.reset-size9.size6{font-size:.5787037em}.katex .fontsize-ensurer.reset-size9.size7,.katex .sizing.reset-size9.size7{font-size:.69444444em}.katex .fontsize-ensurer.reset-size9.size8,.katex .sizing.reset-size9.size8{font-size:.83333333em}.katex .fontsize-ensurer.reset-size9.size9,.katex .sizing.reset-size9.size9{font-size:1em}.katex .fontsize-ensurer.reset-size9.size10,.katex .sizing.reset-size9.size10{font-size:1.20023148em}.katex .fontsize-ensurer.reset-size9.size11,.katex .sizing.reset-size9.size11{font-size:1.43981481em}.katex .fontsize-ensurer.reset-size10.size1,.katex .sizing.reset-size10.size1{font-size:.24108004em}.katex .fontsize-ensurer.reset-size10.size2,.katex .sizing.reset-size10.size2{font-size:.28929605em}.katex .fontsize-ensurer.reset-size10.size3,.katex .sizing.reset-size10.size3{font-size:.33751205em}.katex .fontsize-ensurer.reset-size10.size4,.katex .sizing.reset-size10.size4{font-size:.38572806em}.katex .fontsize-ensurer.reset-size10.size5,.katex .sizing.reset-size10.size5{font-size:.43394407em}.katex .fontsize-ensurer.reset-size10.size6,.katex .sizing.reset-size10.size6{font-size:.48216008em}.katex .fontsize-ensurer.reset-size10.size7,.katex .sizing.reset-size10.size7{font-size:.57859209em}.katex .fontsize-ensurer.reset-size10.size8,.katex .sizing.reset-size10.size8{font-size:.69431051em}.katex .fontsize-ensurer.reset-size10.size9,.katex .sizing.reset-size10.size9{font-size:.83317261em}.katex .fontsize-ensurer.reset-size10.size10,.katex .sizing.reset-size10.size10{font-size:1em}.katex .fontsize-ensurer.reset-size10.size11,.katex .sizing.reset-size10.size11{font-size:1.19961427em}.katex .fontsize-ensurer.reset-size11.size1,.katex .sizing.reset-size11.size1{font-size:.20096463em}.katex .fontsize-ensurer.reset-size11.size2,.katex .sizing.reset-size11.size2{font-size:.24115756em}.katex .fontsize-ensurer.reset-size11.size3,.katex .sizing.reset-size11.size3{font-size:.28135048em}.katex .fontsize-ensurer.reset-size11.size4,.katex .sizing.reset-size11.size4{font-size:.32154341em}.katex .fontsize-ensurer.reset-size11.size5,.katex .sizing.reset-size11.size5{font-size:.36173633em}.katex .fontsize-ensurer.reset-size11.size6,.katex .sizing.reset-size11.size6{font-size:.40192926em}.katex .fontsize-ensurer.reset-size11.size7,.katex .sizing.reset-size11.size7{font-size:.48231511em}.katex .fontsize-ensurer.reset-size11.size8,.katex .sizing.reset-size11.size8{font-size:.57877814em}.katex .fontsize-ensurer.reset-size11.size9,.katex .sizing.reset-size11.size9{font-size:.69453376em}.katex .fontsize-ensurer.reset-size11.size10,.katex .sizing.reset-size11.size10{font-size:.83360129em}.katex .fontsize-ensurer.reset-size11.size11,.katex .sizing.reset-size11.size11{font-size:1em}.katex .delimsizing.size1{font-family:KaTeX_Size1}.katex .delimsizing.size2{font-family:KaTeX_Size2}.katex .delimsizing.size3{font-family:KaTeX_Size3}.katex .delimsizing.size4{font-family:KaTeX_Size4}.katex .delimsizing.mult .delim-size1>span{font-family:KaTeX_Size1}.katex .delimsizing.mult .delim-size4>span{font-family:KaTeX_Size4}.katex .nulldelimiter{display:inline-block;width:.12em}.katex .delimcenter,.katex .op-symbol{position:relative}.katex .op-symbol.small-op{font-family:KaTeX_Size1}.katex .op-symbol.large-op{font-family:KaTeX_Size2}.katex .accent>.vlist-t,.katex .op-limits>.vlist-t{text-align:center}.katex .accent .accent-body{position:relative}.katex .accent .accent-body:not(.accent-full){width:0}.katex .overlay{display:block}.katex .mtable .vertical-separator{display:inline-block;min-width:1px}.katex .mtable .arraycolsep{display:inline-block}.katex .mtable .col-align-c>.vlist-t{text-align:center}.katex .mtable .col-align-l>.vlist-t{text-align:left}.katex .mtable .col-align-r>.vlist-t{text-align:right}.katex .svg-align{text-align:left}.katex svg{display:block;position:absolute;width:100%;height:inherit;fill:currentColor;stroke:currentColor;fill-rule:nonzero;fill-opacity:1;stroke-width:1;stroke-linecap:butt;stroke-linejoin:miter;stroke-miterlimit:4;stroke-dasharray:none;stroke-dashoffset:0;stroke-opacity:1}.katex svg path{stroke:none}.katex img{border-style:none;min-width:0;min-height:0;max-width:none;max-height:none}.katex .stretchy{width:100%;display:block;position:relative;overflow:hidden}.katex .stretchy:after,.katex .stretchy:before{content:""}.katex .hide-tail{width:100%;position:relative;overflow:hidden}.katex .halfarrow-left{position:absolute;left:0;width:50.2%;overflow:hidden}.katex .halfarrow-right{position:absolute;right:0;width:50.2%;overflow:hidden}.katex .brace-left{position:absolute;left:0;width:25.1%;overflow:hidden}.katex .brace-center{position:absolute;left:25%;width:50%;overflow:hidden}.katex .brace-right{position:absolute;right:0;width:25.1%;overflow:hidden}.katex .x-arrow-pad{padding:0 .5em}.katex .cd-arrow-pad{padding:0 .55556em 0 .27778em}.katex .mover,.katex .munder,.katex .x-arrow{text-align:center}.katex .boxpad{padding:0 .3em}.katex .fbox,.katex .fcolorbox{box-sizing:border-box;border:.04em solid}.katex .cancel-pad{padding:0 .2em}.katex .cancel-lap{margin-left:-.2em;margin-right:-.2em}.katex .sout{border-bottom-style:solid;border-bottom-width:.08em}.katex .angl{box-sizing:border-content;border-top:.049em solid;border-right:.049em solid;margin-right:.03889em}.katex .anglpad{padding:0 .03889em}.katex .eqn-num:before{counter-increment:katexEqnNo;content:"(" counter(katexEqnNo) ")"}.katex .mml-eqn-num:before{counter-increment:mmlEqnNo;content:"(" counter(mmlEqnNo) ")"}.katex .mtr-glue{width:50%}.katex .cd-vert-arrow{display:inline-block;position:relative}.katex .cd-label-left{display:inline-block;position:absolute;right:calc(50% + .3em);text-align:left}.katex .cd-label-right{display:inline-block;position:absolute;left:calc(50% + .3em);text-align:right}.katex-display{display:block;margin:1em 0;text-align:center}.katex-display>.katex{display:block;text-align:center;white-space:nowrap}.katex-display>.katex>.katex-html{display:block;position:relative}.katex-display>.katex>.katex-html>.tag{position:absolute;right:0}.katex-display.leqno>.katex>.katex-html>.tag{left:0;right:auto}.katex-display.fleqn>.katex{text-align:left;padding-left:2em}body{counter-reset:katexEqnNo mmlEqnNo}

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/

.katex-error {
	color: var(--vscode-editorError-foreground);
}

</style>
        
        <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Microsoft/vscode/extensions/markdown-language-features/media/markdown.css">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Microsoft/vscode/extensions/markdown-language-features/media/highlight.css">
<style>
            body {
                font-family: -apple-system, BlinkMacSystemFont, 'Segoe WPC', 'Segoe UI', system-ui, 'Ubuntu', 'Droid Sans', sans-serif;
                font-size: 14px;
                line-height: 1.6;
            }
        </style>
        <style>
.task-list-item { list-style-type: none; } .task-list-item-checkbox { margin-left: -20px; vertical-align: middle; }
</style>
        
        
        
    </head>
    <body class="vscode-body vscode-light">
        <h1 id="leetcode刷题笔记">LeetCode刷题笔记</h1>
<ul>
<li><a href="#leetcode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0">LeetCode刷题笔记</a>
<ul>
<li><a href="#202136">2021.3.6</a>
<ul>
<li><a href="#169%E5%A4%9A%E6%95%B0%E5%85%83%E7%B4%A0%E5%93%88%E5%B8%8C%E8%A1%A8">169.多数元素（哈希表）</a></li>
<li><a href="#232%E7%94%A8%E6%A0%88%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97%E6%A0%88">232.用栈实现队列（栈）</a></li>
<li><a href="#354%E4%BF%84%E7%BD%97%E6%96%AF%E5%A5%97%E5%A8%83%E4%BF%A1%E5%B0%81%E9%97%AE%E9%A2%98%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92">354.俄罗斯套娃信封问题(动态规划)</a></li>
</ul>
</li>
<li><a href="#202137">2021.3.7</a>
<ul>
<li><a href="#131%E5%88%86%E5%89%B2%E5%9B%9E%E6%96%87%E4%B8%B2%E5%9B%9E%E6%BA%AF%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E9%A2%84%E5%A4%84%E7%90%86">131.分割回文串(回溯+动态规划预处理)</a></li>
<li><a href="#136%E5%8F%AA%E5%87%BA%E7%8E%B0%E4%B8%80%E6%AC%A1%E7%9A%84%E6%95%B0%E5%AD%97%E4%BD%8D%E8%BF%90%E7%AE%97">136.只出现一次的数字(位运算)</a></li>
<li><a href="#240%E6%90%9C%E7%B4%A2%E4%BA%8C%E7%BB%B4%E7%9F%A9%E9%98%B5%E6%95%B0%E7%BB%84">240.搜索二维矩阵||(数组)</a></li>
<li><a href="#503%E4%B8%8B%E4%B8%80%E4%B8%AA%E6%9B%B4%E5%A4%A7%E5%85%83%E7%B4%A0%E5%8D%95%E8%B0%83%E6%A0%88%E5%BE%AA%E7%8E%AF%E6%95%B0%E7%BB%84">503.下一个更大元素||(单调栈+循环数组)</a></li>
<li><a href="#304%E4%BA%8C%E7%BB%B4%E5%8C%BA%E5%9F%9F%E5%92%8C%E6%A3%80%E7%B4%A2---%E7%9F%A9%E9%98%B5%E4%B8%8D%E5%8F%AF%E5%8F%98%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92">304.二维区域和检索 - 矩阵不可变(动态规划)</a></li>
<li><a href="#338%E6%AF%94%E7%89%B9%E4%BD%8D%E8%AE%A1%E6%95%B0%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92">338.比特位计数(动态规划)</a></li>
</ul>
</li>
<li><a href="#202138">2021.3.8</a>
<ul>
<li><a href="#132%E5%88%86%E5%89%B2%E5%9B%9E%E6%96%87%E4%B8%B2%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92">132.分割回文串||(动态规划)</a></li>
</ul>
</li>
<li><a href="#202139">2021.3.9</a>
<ul>
<li><a href="#1047%E5%88%A0%E9%99%A4%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E7%9A%84%E6%89%80%E6%9C%89%E7%9B%B8%E9%82%BB%E9%87%8D%E5%A4%8D%E9%A1%B9%E6%A0%88%E5%AD%97%E7%AC%A6%E4%B8%B2">1047.删除字符串中的所有相邻重复项(栈、字符串)</a></li>
</ul>
</li>
<li><a href="#2021310">2021.3.10</a>
<ul>
<li><a href="#224%E5%9F%BA%E6%9C%AC%E8%AE%A1%E7%AE%97%E5%99%A8%E6%A0%88">224.基本计算器(栈)</a></li>
</ul>
</li>
<li><a href="#2021311">2021.3.11</a>
<ul>
<li><a href="#227%E5%9F%BA%E6%9C%AC%E8%AE%A1%E7%AE%97%E5%99%A8%E6%A0%88">227.基本计算器||(栈)</a></li>
</ul>
</li>
<li><a href="#2021314">2021.3.14</a>
<ul>
<li><a href="#705%E8%AE%BE%E8%AE%A1%E5%93%88%E5%B8%8C%E9%9B%86%E5%90%88c%E5%AE%B9%E5%99%A8">705.设计哈希集合(c++容器)</a></li>
<li><a href="#706%E8%AE%BE%E8%AE%A1%E5%93%88%E5%B8%8C%E6%98%A0%E5%B0%84c%E5%AE%B9%E5%99%A8">706.设计哈希映射(c++容器)</a></li>
<li><a href="#331%E9%AA%8C%E8%AF%81%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%89%8D%E5%BA%8F%E5%BA%8F%E5%88%97%E5%8C%96%E6%A0%88%E8%AE%A1%E6%95%B0">331.验证二叉树的前序序列化(栈、计数)</a></li>
</ul>
</li>
<li><a href="#2021315">2021.3.15</a>
<ul>
<li><a href="#54%E8%9E%BA%E6%97%8B%E7%9F%A9%E9%98%B5%E6%95%B0%E7%BB%84">54.螺旋矩阵(数组)</a></li>
</ul>
</li>
<li><a href="#2021316">2021.3.16</a>
<ul>
<li><a href="#59%E8%9E%BA%E6%97%8B%E7%9F%A9%E9%98%B5%E6%95%B0%E7%BB%84">59.螺旋矩阵||(数组)</a></li>
</ul>
</li>
<li><a href="#2021317">2021.3.17</a>
<ul>
<li><a href="#115%E4%B8%8D%E5%90%8C%E7%9A%84%E5%AD%90%E5%BA%8F%E5%88%97%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92">115.不同的子序列(动态规划)</a></li>
</ul>
</li>
<li><a href="#2021318">2021.3.18</a>
<ul>
<li><a href="#92%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8%E9%93%BE%E8%A1%A8">92.反转链表||(链表)</a></li>
</ul>
</li>
<li><a href="#2021319">2021.3.19</a>
<ul>
<li><a href="#1603%E8%AE%BE%E8%AE%A1%E5%81%9C%E8%BD%A6%E7%B3%BB%E7%BB%9F%E7%AE%80%E5%8D%95%E9%A2%98">1603.设计停车系统(简单题)</a></li>
<li><a href="#217%E5%AD%98%E5%9C%A8%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A0%E5%93%88%E5%B8%8C%E9%9B%86%E5%90%88">217.存在重复元素(哈希集合)</a></li>
</ul>
</li>
<li><a href="#2021320">2021.3.20</a>
<ul>
<li><a href="#150%E9%80%86%E6%B3%A2%E5%85%B0%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%B1%82%E5%80%BC%E6%A0%88">150.逆波兰表达式求值(栈)</a></li>
</ul>
</li>
<li><a href="#2021321">2021.3.21</a>
<ul>
<li><a href="#73%E7%9F%A9%E9%98%B5%E7%BD%AE%E9%9B%B6%E7%9F%A9%E9%98%B5%E5%8E%9F%E5%9C%B0%E7%AE%97%E6%B3%95">73.矩阵置零(矩阵、原地算法)</a>
<ul>
<li><a href="#%E5%8E%9F%E5%9C%B0%E7%AE%97%E6%B3%95">原地算法</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#2021322">2021.3.22</a>
<ul>
<li><a href="#191%E4%BD%8D1%E7%9A%84%E4%B8%AA%E6%95%B0%E4%BD%8D%E8%BF%90%E7%AE%97">191.位1的个数(位运算)</a></li>
</ul>
</li>
<li><a href="#2021323">2021.3.23</a>
<ul>
<li><a href="#341%E6%89%81%E5%B9%B3%E5%8C%96%E5%B5%8C%E5%A5%97%E5%88%97%E8%A1%A8%E8%BF%AD%E4%BB%A3%E5%99%A8%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2">341.扁平化嵌套列表迭代器(深度优先搜索)</a></li>
</ul>
</li>
<li><a href="#2021324">2021.3.24</a>
<ul>
<li><a href="#456132%E6%A8%A1%E5%BC%8F%E5%8D%95%E8%B0%83%E6%A0%88">456.132模式(单调栈)</a></li>
</ul>
</li>
<li><a href="#2021325">2021.3.25</a>
<ul>
<li><a href="#82%E5%88%A0%E9%99%A4%E6%8E%92%E5%BA%8F%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A0%E9%93%BE%E8%A1%A8">82.删除排序链表中的重复元素||(链表)</a></li>
</ul>
</li>
<li><a href="#2021327">2021.3.27</a>
<ul>
<li><a href="#83%E5%88%A0%E9%99%A4%E6%8E%92%E5%BA%8F%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A0%E9%93%BE%E8%A1%A8">83.删除排序链表中的重复元素(链表)</a></li>
<li><a href="#61%E6%97%8B%E8%BD%AC%E9%93%BE%E8%A1%A8%E9%93%BE%E8%A1%A8">61.旋转链表(链表)</a></li>
</ul>
</li>
<li><a href="#202142">2021.4.2</a>
<ul>
<li><a href="#%E9%9D%A2%E8%AF%95%E9%A2%981721%E7%9B%B4%E6%96%B9%E5%9B%BE%E7%9A%84%E6%B0%B4%E9%87%8F%E5%8F%8C%E6%8C%87%E9%92%88">面试题17.21.直方图的水量(双指针)</a></li>
<li><a href="#1006%E7%AC%A8%E9%98%B6%E4%B9%98%E6%95%B0%E5%AD%A6">1006.笨阶乘(数学)</a></li>
</ul>
</li>
<li><a href="#202144">2021.4.4</a>
<ul>
<li><a href="#781%E6%A3%AE%E6%9E%97%E4%B8%AD%E7%9A%84%E5%85%94%E5%AD%90%E8%B4%AA%E5%BF%83">781.森林中的兔子(贪心)</a></li>
</ul>
</li>
<li><a href="#202145">2021.4.5</a>
<ul>
<li><a href="#88%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E5%8F%8C%E6%8C%87%E9%92%88">88.合并两个有序数组(双指针)</a></li>
</ul>
</li>
<li><a href="#202146">2021.4.6</a>
<ul>
<li><a href="#80%E5%88%A0%E9%99%A4%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E9%A1%B9">80.删除有序数组中的重复项||</a></li>
</ul>
</li>
<li><a href="#202147">2021.4.7</a>
<ul>
<li><a href="#81%E6%90%9C%E7%B4%A2%E6%97%8B%E8%BD%AC%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84">81.搜索旋转排序数组||</a></li>
</ul>
</li>
<li><a href="#2021411">2021.4.11</a>
<ul>
<li><a href="#264%E4%B8%91%E6%95%B0%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92">264.丑数||(动态规划)</a></li>
</ul>
</li>
<li><a href="#202179">2021.7.9</a>
<ul>
<li><a href="#5%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92">5.最长回文子串(动态规划)</a></li>
<li><a href="#1710-%E4%B8%BB%E8%A6%81%E5%85%83%E7%B4%A0mapboyer-moore-%E6%8A%95%E7%A5%A8%E7%AE%97%E6%B3%95">17.10 主要元素(map、Boyer-Moore 投票算法)</a></li>
</ul>
</li>
<li><a href="#2021710">2021.7.10</a>
<ul>
<li><a href="#21%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8%E8%BF%AD%E4%BB%A3%E6%B3%95">21.合并两个有序链表(迭代法)</a></li>
<li><a href="#22%E6%8B%AC%E5%8F%B7%E7%94%9F%E6%88%90%E5%9B%9E%E6%BA%AF%E6%B3%95">22.括号生成(回溯法)</a></li>
</ul>
</li>
<li><a href="#2021712">2021.7.12</a>
<ul>
<li><a href="#275h%E6%8C%87%E6%95%B0%E2%85%B12%E5%88%86%E6%B3%95">275.H指数Ⅱ(2分法)</a></li>
</ul>
</li>
<li><a href="#202182">2021.8.2</a>
<ul>
<li><a href="#94%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86%E9%80%92%E5%BD%92morris">94.二叉树的中序遍历(递归、Morris)</a></li>
<li><a href="#95%E4%B8%8D%E5%90%8C%E7%9A%84%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E2%85%B1%E5%9B%9E%E6%BA%AF">95.不同的二叉搜索树Ⅱ(回溯)</a></li>
<li><a href="#104%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%A4%A7%E6%B7%B1%E5%BA%A6dfs">104.二叉树的最大深度(dfs)</a></li>
<li><a href="#671%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E7%AC%AC%E4%BA%8C%E5%B0%8F%E7%9A%84%E8%8A%82%E7%82%B9dfs">671.二叉树中第二小的节点(dfs)</a></li>
<li><a href="#1337%E7%9F%A9%E9%98%B5%E4%B8%AD%E6%88%98%E6%96%97%E5%8A%9B%E6%9C%80%E5%BC%B1%E7%9A%84k%E8%A1%8C%E7%BA%B5%E5%90%91%E9%81%8D%E5%8E%86">1337.矩阵中战斗力最弱的K行(纵向遍历)</a></li>
</ul>
</li>
<li><a href="#202186">2021.8.6</a>
<ul>
<li><a href="#27%E7%A7%BB%E9%99%A4%E5%85%83%E7%B4%A0">27.移除元素</a></li>
<li><a href="#31%E4%B8%8B%E4%B8%80%E4%B8%AA%E5%BA%8F%E5%88%97">31.下一个序列</a></li>
<li><a href="#847%E8%AE%BF%E9%97%AE%E6%89%80%E6%9C%89%E8%8A%82%E7%82%B9%E7%9A%84%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84">847.访问所有节点的最短路径</a></li>
</ul>
</li>
<li><a href="#810">8.10</a>
<ul>
<li><a href="#413%E7%AD%89%E5%B7%AE%E6%95%B0%E5%88%97%E5%88%92%E5%88%86">413.等差数列划分</a></li>
</ul>
</li>
<li><a href="#812">8.12</a>
<ul>
<li><a href="#53%E6%9C%80%E5%A4%A7%E5%AD%90%E5%BA%8F%E5%92%8C">53.最大子序和</a></li>
<li><a href="#516%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E5%BA%8F%E5%88%97">516.最长回文子序列</a></li>
</ul>
</li>
<li><a href="#813">8.13</a>
<ul>
<li><a href="#143%E9%87%8D%E6%8E%92%E9%93%BE%E8%A1%A8">143.重排链表</a></li>
</ul>
</li>
<li><a href="#815">8.15</a>
<ul>
<li><a href="#576%E5%87%BA%E7%95%8C%E7%9A%84%E8%B7%AF%E5%BE%84%E6%95%B0">576.出界的路径数</a></li>
</ul>
</li>
<li><a href="#818">8.18</a>
<ul>
<li><a href="#%E5%89%91%E6%8C%87offer09%E7%94%A8%E4%B8%A4%E4%B8%AA%E6%A0%88%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97">剑指offer09.用两个栈实现队列</a></li>
<li><a href="#%E5%89%91%E6%8C%87offer30%E5%8C%85%E5%90%ABmin%E5%87%BD%E6%95%B0%E7%9A%84%E6%A0%88">剑指offer30.包含min函数的栈</a></li>
</ul>
</li>
<li><a href="#819">8.19</a>
<ul>
<li><a href="#345%E5%8F%8D%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E7%9A%84%E5%85%83%E9%9F%B3%E5%AD%97%E6%AF%8D">345.反转字符串中的元音字母</a></li>
<li><a href="#%E5%89%91%E6%8C%87offer06%E4%BB%8E%E5%B0%BE%E5%88%B0%E5%A4%B4%E6%89%93%E5%8D%B0%E9%93%BE%E8%A1%A8">剑指offer06.从尾到头打印链表</a></li>
<li><a href="#%E5%89%91%E6%8C%87offer24%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8">剑指offer24.反转链表</a></li>
</ul>
</li>
<li><a href="#820">8.20</a>
<ul>
<li><a href="#541%E5%8F%8D%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B22">541.反转字符串2</a></li>
<li><a href="#%E5%89%91%E6%8C%87offer05%E6%9B%BF%E6%8D%A2%E7%A9%BA%E6%A0%BC">剑指offer05.替换空格</a></li>
<li><a href="#%E5%89%91%E6%8C%87offer35%E5%A4%8D%E6%9D%82%E9%93%BE%E8%A1%A8%E7%9A%84%E5%A4%8D%E5%88%B6">剑指offer35.复杂链表的复制</a></li>
<li><a href="#%E5%89%91%E6%8C%87offer58-%E4%BA%8C%E5%B7%A6%E6%97%8B%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2">剑指offer58-二.左旋转字符串</a></li>
</ul>
</li>
<li><a href="#821">8.21</a>
<ul>
<li><a href="#443%E5%8E%8B%E7%BC%A9%E5%AD%97%E7%AC%A6%E4%B8%B2">443.压缩字符串</a></li>
</ul>
</li>
<li><a href="#822">8.22</a>
<ul>
<li><a href="#789%E9%80%83%E8%84%B1%E9%98%BB%E7%A2%8D%E8%80%85">789.逃脱阻碍者</a></li>
<li><a href="#%E5%89%91%E6%8C%87offer03%E6%95%B0%E7%BB%84%E4%B8%AD%E9%87%8D%E5%A4%8D%E7%9A%84%E6%95%B0%E5%AD%97">剑指offer03.数组中重复的数字</a></li>
<li><a href="#%E5%89%91%E6%8C%87offer04%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E6%9F%A5%E6%89%BE">剑指offer04.二维数组中的查找</a></li>
<li><a href="#%E5%89%91%E6%8C%87offer11%E6%97%8B%E8%BD%AC%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%B0%8F%E6%95%B0%E5%AD%97">剑指offer11.旋转数组的最小数字</a></li>
<li><a href="#%E5%89%91%E6%8C%87offer53-i%E5%9C%A8%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E6%9F%A5%E6%89%BE%E6%95%B0%E5%AD%97i">剑指offer53-I.在排序数组中查找数字I</a></li>
<li><a href="#%E5%89%91%E6%8C%87offer53-%E2%85%B10n-1%E4%B8%AD%E7%BC%BA%E5%A4%B1%E7%9A%84%E6%95%B0%E5%AD%97">剑指offer53-Ⅱ.0~n-1中缺失的数字</a></li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="202136">2021.3.6</h2>
<h3 id="169多数元素哈希表">169.多数元素（哈希表）</h3>
<p><a href="https://leetcode-cn.com/problems/majority-element/">多数元素</a></p>
<pre><code class="language-c++"><div><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;iostream&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;vector&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;map&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;cstdlib&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;ctime&gt;</span></span>
<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;
<span class="hljs-comment">//1.map存储每个数组元素的出现次数 </span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> {</span>
<span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">majorityElement</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums)</span> </span>{
        <span class="hljs-keyword">if</span>(nums.size()==<span class="hljs-number">1</span>)<span class="hljs-keyword">return</span> nums[<span class="hljs-number">0</span>];
        <span class="hljs-built_in">map</span> &lt;<span class="hljs-keyword">int</span>,<span class="hljs-keyword">int</span>&gt; myMap;
        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;nums.size();i++)
        {
            <span class="hljs-built_in">map</span>&lt;<span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>&gt;::iterator iter=myMap.find(nums[i]);
            <span class="hljs-keyword">if</span>(iter!=myMap.end())
            {
                <span class="hljs-keyword">if</span>((++iter-&gt;second)&gt;(nums.size()/<span class="hljs-number">2</span>))
                {
                    <span class="hljs-keyword">return</span> iter-&gt;first;
                }
                
            }
            <span class="hljs-keyword">else</span>
            {
                myMap.insert(<span class="hljs-built_in">pair</span>&lt;<span class="hljs-keyword">int</span>,<span class="hljs-keyword">int</span>&gt;(nums[i],<span class="hljs-number">1</span>));
            }
        }
        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
    }
};
<span class="hljs-comment">//2.随机法</span>
<span class="hljs-comment">//随机一个下标 遍历获得该元素出现次数 大于n/2即为众数</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> {</span>
<span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">majorityElement</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums)</span> </span>{
        <span class="hljs-keyword">unsigned</span> seed;
        seed=time(<span class="hljs-number">0</span>);
        srand(seed);
        <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>)
        {
            <span class="hljs-keyword">int</span> index=rand()%nums.size();
            <span class="hljs-keyword">int</span> cnt=<span class="hljs-number">0</span>;
            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;nums.size();i++)
            {
                <span class="hljs-keyword">if</span>(nums[index]==nums[i])
                {
                    cnt++;
                }
                <span class="hljs-keyword">if</span>(cnt&gt;(nums.size()/<span class="hljs-number">2</span>))
                {
                    <span class="hljs-keyword">return</span> nums[index];
                }
            }
        }
    }
};
<span class="hljs-comment">//3.分治法</span>
<span class="hljs-comment">//数组的众数也一定是对半分子数组的众数</span>
<span class="hljs-comment">//4.Boyer-Moore 投票算法</span>
<span class="hljs-comment">//因为超过2/n个的数，所以多数为A 其他数为B。</span>
<span class="hljs-comment">// 公式如下就满足题意 A - B &gt; 1</span>
<span class="hljs-comment">// 所以遍历数组，如果是A就count++,如果是B就count--。</span>
<span class="hljs-comment">// 如果count为0，就说明不是多数就将当前的值设置成多数，并重新去count++。</span>
<span class="hljs-comment">// 这样遍历完成后的数一定是多数。</span>


</div></code></pre>
<h3 id="232用栈实现队列栈">232.用栈实现队列（栈）</h3>
<p><a href="https://leetcode-cn.com/problems/implement-queue-using-stacks/">用栈实现队列</a></p>
<pre><code class="language-c++"><div><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;iostream&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;vector&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;algorithm&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;stack&gt;</span></span>
<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;
<span class="hljs-comment">//双栈 一个作push操作 一个作pop peek操作</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyQueue</span> {</span>
    <span class="hljs-keyword">private</span>:
    <span class="hljs-built_in">stack</span>&lt;<span class="hljs-keyword">int</span>&gt; inStack,outStack;
    <span class="hljs-comment">//进栈元素反转进入出栈</span>
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">inToOut</span><span class="hljs-params">()</span>
    </span>{
        <span class="hljs-keyword">while</span>(!inStack.empty())
        {
            outStack.push(inStack.top());
            inStack.pop();
        }
    }
<span class="hljs-keyword">public</span>:
    <span class="hljs-comment">/** Initialize your data structure here. */</span>
    MyQueue() {

    }
    
    <span class="hljs-comment">/** Push element x to the back of queue. */</span>
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">push</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span> </span>{
        inStack.push(x);
    }
    
    <span class="hljs-comment">/** Removes the element from in front of queue and returns that element. */</span>
    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">pop</span><span class="hljs-params">()</span> </span>{
        <span class="hljs-keyword">if</span>(outStack.empty())
        {
            inToOut();
        }
        <span class="hljs-keyword">int</span> num=outStack.top();
        outStack.pop();
        <span class="hljs-keyword">return</span> num;
    }
    
    <span class="hljs-comment">/** Get the front element. */</span>
    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">peek</span><span class="hljs-params">()</span> </span>{
        <span class="hljs-keyword">if</span>(outStack.empty())
        {
            inToOut();
        }
        <span class="hljs-keyword">return</span> outStack.top();
    }
    
    <span class="hljs-comment">/** Returns whether the queue is empty. */</span>
    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">empty</span><span class="hljs-params">()</span> </span>{
        <span class="hljs-keyword">return</span> inStack.empty() &amp;&amp; outStack.empty();
    }
};

<span class="hljs-comment">/**
 * Your MyQueue object will be instantiated and called as such:
 * MyQueue* obj = new MyQueue();
 * obj-&gt;push(x);
 * int param_2 = obj-&gt;pop();
 * int param_3 = obj-&gt;peek();
 * bool param_4 = obj-&gt;empty();
 */</span>
</div></code></pre>
<h3 id="354俄罗斯套娃信封问题动态规划">354.俄罗斯套娃信封问题(动态规划)</h3>
<p><a href="https://leetcode-cn.com/problems/russian-doll-envelopes/">俄罗斯套娃信封问题</a></p>
<pre><code class="language-c++"><div><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;iostream&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;vector&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;algorithm&gt;</span></span>
<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;
<span class="hljs-comment">//动态规划 时On2 空On</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> {</span>
<span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">maxEnvelopes</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; &gt;&amp; envelopes)</span> </span>{
        <span class="hljs-comment">//高位关键字优先升序排序</span>
        <span class="hljs-comment">//低位关键字降序排列（为了通过求最长严格递增子序列的长度得出答案）</span>
        <span class="hljs-keyword">if</span>(envelopes.empty())<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
        <span class="hljs-keyword">int</span> len=envelopes.size();
        <span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">ans</span><span class="hljs-params">(len,<span class="hljs-number">1</span>)</span></span>;
        sort(envelopes.begin(), envelopes.end(), [](<span class="hljs-keyword">const</span> <span class="hljs-keyword">auto</span>&amp; e1, <span class="hljs-keyword">const</span> <span class="hljs-keyword">auto</span>&amp; e2) {
            <span class="hljs-keyword">return</span> e1[<span class="hljs-number">0</span>] &lt; e2[<span class="hljs-number">0</span>] || (e1[<span class="hljs-number">0</span>] == e2[<span class="hljs-number">0</span>] &amp;&amp; e1[<span class="hljs-number">1</span>] &gt; e2[<span class="hljs-number">1</span>]);
        });
        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;len;i++)
        {
            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">0</span>;j&lt;i;j++)
            {
                <span class="hljs-keyword">if</span>(envelopes[j][<span class="hljs-number">1</span>]&lt;envelopes[i][<span class="hljs-number">1</span>])
                {
                    ans[i]=max(ans[i],ans[j]+<span class="hljs-number">1</span>);
                }
            }
        }
        <span class="hljs-keyword">return</span> *max_element(ans.begin(), ans.end());
    }
};

</div></code></pre>
<h2 id="202137">2021.3.7</h2>
<h3 id="131分割回文串回溯动态规划预处理">131.分割回文串(回溯+动态规划预处理)</h3>
<p><a href="https://leetcode-cn.com/problems/palindrome-partitioning/">分割回文串</a></p>
<pre><code class="language-c++"><div><span class="hljs-comment">//131.分割回文串</span>
<span class="hljs-comment">//2021.3.7</span>
<span class="hljs-comment">//回溯+动态规划预处理</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> {</span>
<span class="hljs-keyword">public</span>:
    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">string</span>&gt;&gt; res;
    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">string</span>&gt; ans;
    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&gt; pre;
    <span class="hljs-keyword">int</span> n;
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-built_in">string</span>&amp; str,<span class="hljs-keyword">int</span> i)</span>
    </span>{
        <span class="hljs-comment">//一种分割方案完成</span>
        <span class="hljs-keyword">if</span>(i==n)
        {
            res.push_back(ans);
        }
        <span class="hljs-keyword">else</span>
        {
            <span class="hljs-comment">//找寻从当前下标开始之后的所有分割可能</span>
            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=i;j&lt;str.size();j++)
            {
                <span class="hljs-comment">//下标i~j为回文串</span>
                <span class="hljs-keyword">if</span>(pre[i][j])
                {
                    ans.push_back(str.substr(i,j-i+<span class="hljs-number">1</span>));
                    <span class="hljs-comment">//找寻这次分割后的后续分割方案</span>
                    dfs(str,j+<span class="hljs-number">1</span>);
                    <span class="hljs-comment">//回溯时将ans容器中的该分割方案移除</span>
                    ans.pop_back();
                }
            }
        }
    }
    <span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">string</span>&gt;&gt; <span class="hljs-title">partition</span><span class="hljs-params">(<span class="hljs-built_in">string</span> s)</span> </span>{
        n=s.size();
        pre.assign(n,<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;(n,<span class="hljs-literal">true</span>));
        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=n<span class="hljs-number">-1</span>;i&gt;=<span class="hljs-number">0</span>;i--)
        {
            <span class="hljs-comment">//j初始值设为i+1是为了直接跳过单个字符的判断 默认符合回文</span>
            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=i+<span class="hljs-number">1</span>;j&lt;n;j++)
            {
                pre[i][j]=((s[i]==s[j])&amp;&amp;pre[i+<span class="hljs-number">1</span>][j<span class="hljs-number">-1</span>]);
            }
        }
        dfs(s,<span class="hljs-number">0</span>);
        <span class="hljs-keyword">return</span> res;
    }
};
</div></code></pre>
<h3 id="136只出现一次的数字位运算">136.只出现一次的数字(位运算)</h3>
<p><a href="https://leetcode-cn.com/problems/single-number/">只出现一次的数字</a></p>
<pre><code class="language-c++"><div><span class="hljs-comment">//136.只出现一次的数字</span>
<span class="hljs-comment">//异或运算</span>
<span class="hljs-comment">// 异或运算有以下三个性质。</span>

<span class="hljs-comment">// 任何数和 00 做异或运算，结果仍然是原来的数，即a⊕0=a。</span>
<span class="hljs-comment">// 任何数和其自身做异或运算，结果是 0，即 a⊕a=0。</span>
<span class="hljs-comment">// 异或运算满足交换律和结合律，即 a⊕b⊕a=b⊕a⊕a=b⊕(a⊕a)=b⊕0=b</span>
<span class="hljs-comment">// 所以数组所有元素相异或即为答案</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> {</span>
<span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">singleNumber</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums)</span> </span>{
        <span class="hljs-keyword">int</span> ans=<span class="hljs-number">0</span>;
        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;nums.size();i++)
        {
            ans^=nums[i];
        }
        <span class="hljs-keyword">return</span> ans;
    }
};
</div></code></pre>
<h3 id="240搜索二维矩阵数组">240.搜索二维矩阵||(数组)</h3>
<p><a href="https://leetcode-cn.com/problems/search-a-2d-matrix-ii/">搜索二维矩阵||</a></p>
<pre><code class="language-c++"><div><span class="hljs-comment">//240.搜索二维矩阵||</span>
<span class="hljs-comment">//2021.3.6</span>
<span class="hljs-comment">//由于矩阵元素 向右 向下递增</span>
<span class="hljs-comment">//那么以矩阵左下角为起点 若target&gt;cur 向右遍历 若target&lt;cur 向上遍历</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> {</span>
<span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">searchMatrix</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&gt;&amp; matrix, <span class="hljs-keyword">int</span> target)</span> </span>{
        <span class="hljs-keyword">int</span> row=matrix.size()<span class="hljs-number">-1</span>;
        <span class="hljs-keyword">int</span> col=<span class="hljs-number">0</span>;
        <span class="hljs-keyword">while</span>(row&gt;=<span class="hljs-number">0</span> &amp;&amp; col&lt;matrix[<span class="hljs-number">0</span>].size())
        {
            <span class="hljs-keyword">if</span>(matrix[row][col]==target)<span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(matrix[row][col]&gt;target)row--;
            <span class="hljs-keyword">else</span> col++;
        }
        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
    }
};
</div></code></pre>
<h3 id="503下一个更大元素单调栈循环数组">503.下一个更大元素||(单调栈+循环数组)</h3>
<p><a href="https://leetcode-cn.com/problems/next-greater-element-ii/">下一个更大元素||</a></p>
<pre><code class="language-c++"><div><span class="hljs-comment">//503.下一个更大元素||</span>
<span class="hljs-comment">//2021.3.6</span>
<span class="hljs-comment">//1.暴力法 On2 会超时 n个数 每个数遍历n次 n*n</span>
<span class="hljs-comment">// class Solution {</span>
<span class="hljs-comment">// public:</span>
<span class="hljs-comment">//     vector&lt;int&gt; nextGreaterElements(vector&lt;int&gt;&amp; nums) {</span>
<span class="hljs-comment">//         vector&lt;int&gt; ans;</span>
<span class="hljs-comment">//         if(nums.size()==0 || nums.size()==1)</span>
<span class="hljs-comment">//         {</span>
<span class="hljs-comment">//             ans.push_back(-1);</span>
<span class="hljs-comment">//             return ans;</span>
<span class="hljs-comment">//         }</span>
<span class="hljs-comment">//         for(int i=0;i&lt;nums.size();i++)</span>
<span class="hljs-comment">//         {</span>
<span class="hljs-comment">//             int next=i+1;</span>
<span class="hljs-comment">//             while((next%nums.size())!=i)</span>
<span class="hljs-comment">//             {</span>
<span class="hljs-comment">//                 if(nums[next%nums.size()]&gt;nums[i])</span>
<span class="hljs-comment">//                 {</span>
<span class="hljs-comment">//                     ans.push_back(nums[next%nums.size()]);</span>
<span class="hljs-comment">//                     break;</span>
<span class="hljs-comment">//                 }</span>
<span class="hljs-comment">//                 next++;</span>
<span class="hljs-comment">//             }</span>
<span class="hljs-comment">//             if((next%nums.size())==i)</span>
<span class="hljs-comment">//             {</span>
<span class="hljs-comment">//                 ans.push_back(-1);</span>
<span class="hljs-comment">//             }</span>
<span class="hljs-comment">//         }</span>
<span class="hljs-comment">//         return ans;</span>
<span class="hljs-comment">//     }</span>
<span class="hljs-comment">// };</span>
<span class="hljs-comment">//2.单调栈+循环数组 On 每个数最多遍历到两次 最多进栈两次 最多出栈两次</span>
<span class="hljs-comment">//2 2 4 2 2 后面两个2就需再循环一次数组找到较大值</span>
<span class="hljs-comment">//遍历数组 将栈中索引指向元素小于遍历到的元素 就弹出 并在答案vector对应索引设置该值</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> {</span>
<span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">nextGreaterElements</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums)</span> </span>{
        <span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">ans</span><span class="hljs-params">(nums.size(),<span class="hljs-number">-1</span>)</span></span>;
        <span class="hljs-built_in">stack</span>&lt;<span class="hljs-keyword">int</span>&gt; myStack;
        <span class="hljs-keyword">if</span>(nums.size()==<span class="hljs-number">0</span> || nums.size()==<span class="hljs-number">1</span>)
        {
            <span class="hljs-keyword">return</span> ans;
        }
        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;(<span class="hljs-number">2</span>*nums.size());i++)
        {
            
            <span class="hljs-keyword">while</span>(!myStack.empty() &amp;&amp; (nums[myStack.top()]&lt;nums[i%nums.size()]))
            {
                ans.at(myStack.top())=nums[i%nums.size()];
                myStack.pop();
            }
            
           
            myStack.push(i%nums.size());
        }
        <span class="hljs-keyword">return</span> ans;
    }
};
</div></code></pre>
<h3 id="304二维区域和检索---矩阵不可变动态规划">304.二维区域和检索 - 矩阵不可变(动态规划)</h3>
<p><a href="https://leetcode-cn.com/problems/range-sum-query-2d-immutable/">二维区域和检索 - 矩阵不可变</a></p>
<pre><code class="language-c++"><div><span class="hljs-comment">//304.二维区域和检索 - 矩阵不可变</span>
<span class="hljs-comment">//一维前缀和 时间复杂度 n</span>
<span class="hljs-comment">// class NumMatrix {</span>
<span class="hljs-comment">// public:</span>
<span class="hljs-comment">//     vector&lt;vector&lt;int&gt; &gt; sums;</span>
<span class="hljs-comment">//     NumMatrix(vector&lt;vector&lt;int&gt; &gt;&amp; matrix) {</span>
<span class="hljs-comment">//         int row=matrix.size();</span>
<span class="hljs-comment">//         if(row&gt;0)</span>
<span class="hljs-comment">//         {</span>
<span class="hljs-comment">//             int col=matrix[0].size();</span>
<span class="hljs-comment">//             sums.resize(row,vector&lt;int&gt;(col+1)); </span>
<span class="hljs-comment">//             for(int i=0;i&lt;row;i++)</span>
<span class="hljs-comment">//             {</span>
<span class="hljs-comment">//                 for(int j=0;j&lt;col;j++)</span>
<span class="hljs-comment">//                 {</span>
<span class="hljs-comment">//                     sums[i][j+1]=sums[i][j]+matrix[i][j];</span>
<span class="hljs-comment">//                 }</span>
<span class="hljs-comment">//             }</span>
<span class="hljs-comment">//         }</span>
<span class="hljs-comment">//     }</span>
    
<span class="hljs-comment">//     int sumRegion(int row1, int col1, int row2, int col2) {</span>
<span class="hljs-comment">//         int sum=0;</span>
<span class="hljs-comment">//         if(row1&gt;=0 &amp;&amp; col1&gt;=0)</span>
<span class="hljs-comment">//         {</span>
<span class="hljs-comment">//             for(int i=row1;i&lt;=row2;i++)</span>
<span class="hljs-comment">//             {</span>
<span class="hljs-comment">//                 sum+=(sums[i][col2+1]-sums[i][col1]);</span>
<span class="hljs-comment">//             }</span>
<span class="hljs-comment">//         }</span>
<span class="hljs-comment">//         return sum;</span>
<span class="hljs-comment">//     }</span>
<span class="hljs-comment">// };</span>
<span class="hljs-comment">//二维前缀和 时间复杂度 1</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NumMatrix</span> {</span>
<span class="hljs-keyword">public</span>:
    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; &gt; sums;
    NumMatrix(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; &gt;&amp; matrix) {
        <span class="hljs-keyword">int</span> row=matrix.size();
        <span class="hljs-keyword">if</span>(row&gt;<span class="hljs-number">0</span>)
        {
            <span class="hljs-keyword">int</span> col=matrix[<span class="hljs-number">0</span>].size();
            <span class="hljs-keyword">if</span>(col&gt;<span class="hljs-number">0</span>)
            {
                sums.resize(row+<span class="hljs-number">1</span>,<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;(col+<span class="hljs-number">1</span>));
                <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;row;i++)
                {
                    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">0</span>;j&lt;col;j++)
                    {
                        sums[i+<span class="hljs-number">1</span>][j+<span class="hljs-number">1</span>]=sums[i][j+<span class="hljs-number">1</span>]+sums[i+<span class="hljs-number">1</span>][j]-sums[i][j]+matrix[i][j];
                    }
                }
            }
        }
    }
    
    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">sumRegion</span><span class="hljs-params">(<span class="hljs-keyword">int</span> row1, <span class="hljs-keyword">int</span> col1, <span class="hljs-keyword">int</span> row2, <span class="hljs-keyword">int</span> col2)</span> </span>{
        <span class="hljs-keyword">return</span> sums[row2+<span class="hljs-number">1</span>][col2+<span class="hljs-number">1</span>]-sums[row2+<span class="hljs-number">1</span>][col1]-sums[row1][col2+<span class="hljs-number">1</span>]+sums[row1][col1];
    }
};
<span class="hljs-comment">/**
 * Your NumMatrix object will be instantiated and called as such:
 * NumMatrix* obj = new NumMatrix(matrix);
 * int param_1 = obj-&gt;sumRegion(row1,col1,row2,col2);
 */</span>
</div></code></pre>
<h3 id="338比特位计数动态规划">338.比特位计数(动态规划)</h3>
<p><a href="https://leetcode-cn.com/problems/counting-bits/">比特位计数</a></p>
<pre><code class="language-c++"><div><span class="hljs-comment">//338.比特位计数</span>
<span class="hljs-comment">//利用库函数 直接求</span>
<span class="hljs-comment">// class Solution {</span>
<span class="hljs-comment">// public:</span>
<span class="hljs-comment">//     vector&lt;int&gt; countBits(int num) {</span>
<span class="hljs-comment">//         vector&lt;int&gt; ans;</span>
<span class="hljs-comment">//         for(int i=0;i&lt;=num;i++)</span>
<span class="hljs-comment">//         {</span>
<span class="hljs-comment">//             int cnt=__builtin_popcount(i);</span>
           
<span class="hljs-comment">//             ans.push_back(cnt);</span>
<span class="hljs-comment">//         }</span>
<span class="hljs-comment">//         return ans;</span>
<span class="hljs-comment">//     }</span>
    
<span class="hljs-comment">// };</span>
<span class="hljs-comment">//动态规划</span>
<span class="hljs-comment">//最高有效位 状态转移方程 ans[i]=ans[i-highBit]+1</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> {</span>
<span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">countBits</span><span class="hljs-params">(<span class="hljs-keyword">int</span> num)</span> </span>{
        <span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">ans</span><span class="hljs-params">(num+<span class="hljs-number">1</span>)</span></span>;
        ans[<span class="hljs-number">0</span>]=<span class="hljs-number">0</span>;
        <span class="hljs-keyword">int</span> highBit=<span class="hljs-number">0</span>;
        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=num;i++)
        {
            <span class="hljs-comment">//若是只有最高位为1 100 和 011 相与必为0</span>
            <span class="hljs-keyword">if</span>((i&amp;(i<span class="hljs-number">-1</span>))==<span class="hljs-number">0</span>)
            {
                highBit=i;
                ans[i]=<span class="hljs-number">1</span>;
            }
            <span class="hljs-comment">//若不是 比如 111（7） 111-100（最高有效位）=011的1的个数+1</span>
            <span class="hljs-keyword">else</span>
            {
                ans[i]=ans[i-highBit]+<span class="hljs-number">1</span>;
            }
        }
        <span class="hljs-keyword">return</span> ans;
    }
};
</div></code></pre>
<h2 id="202138">2021.3.8</h2>
<h3 id="132分割回文串动态规划">132.分割回文串||(动态规划)</h3>
<p><a href="https://leetcode-cn.com/problems/palindrome-partitioning-ii/solution/fen-ge-hui-wen-chuan-ii-by-leetcode-solu-norx/">分割回文串||</a></p>
<pre><code class="language-c++"><div><span class="hljs-comment">//132.分割回文串||</span>
<span class="hljs-comment">//2021.3.8</span>
<span class="hljs-comment">//1.dfs会栈溢出 递归太多</span>
<span class="hljs-comment">// class Solution {</span>
<span class="hljs-comment">// public:</span>
<span class="hljs-comment">//     vector&lt;vector&lt;int&gt;&gt; pre;</span>
<span class="hljs-comment">//     int n;</span>
<span class="hljs-comment">//     int cnt=0;</span>
<span class="hljs-comment">//     int ans=INT_LEAST32_MAX;</span>
<span class="hljs-comment">//     void dfs(const string&amp; s,int i)</span>
<span class="hljs-comment">//     {</span>
<span class="hljs-comment">//         if(i==n)</span>
<span class="hljs-comment">//         {</span>
<span class="hljs-comment">//             ans=min(cnt,ans);</span>
<span class="hljs-comment">//             return;</span>
<span class="hljs-comment">//         }</span>
<span class="hljs-comment">//         for(int j=n-1;j&gt;=0;j--)</span>
<span class="hljs-comment">//         {</span>
<span class="hljs-comment">//             if(pre[i][j])</span>
<span class="hljs-comment">//             {</span>
<span class="hljs-comment">//                 cnt++;</span>
<span class="hljs-comment">//                 dfs(s,j+1);</span>
<span class="hljs-comment">//                 cnt--;</span>
<span class="hljs-comment">//             }</span>
<span class="hljs-comment">//         }</span>
        
        
<span class="hljs-comment">//     }</span>
<span class="hljs-comment">//     int minCut(string s) {</span>
<span class="hljs-comment">//         n=s.size();</span>
<span class="hljs-comment">//         if(n==1)return 0;</span>
<span class="hljs-comment">//         pre.assign(n,vector&lt;int&gt;(n,true));</span>
<span class="hljs-comment">//         for(int i=n-1;i&gt;=0;i--)</span>
<span class="hljs-comment">//         {</span>
<span class="hljs-comment">//             for(int j=i+1;j&lt;n;j++)</span>
<span class="hljs-comment">//             {</span>
<span class="hljs-comment">//                 pre[i][j]=(s[i]==s[j]&amp;&amp;pre[i+1][j-1]);</span>
<span class="hljs-comment">//             }</span>
<span class="hljs-comment">//         }</span>
<span class="hljs-comment">//         dfs(s,0);</span>
<span class="hljs-comment">//         ans--;</span>
<span class="hljs-comment">//         return ans;</span>
<span class="hljs-comment">//     }</span>
<span class="hljs-comment">// };</span>
<span class="hljs-comment">//2.动态规划</span>
<span class="hljs-comment">//状态转移方程 </span>
<span class="hljs-comment">//我们枚举最后一个回文串的起始位置 j+1，保证 s[j+1..i] 是一个回文串，那么 f[i] 就可以从 f[j] 转移而来，附加 1 次额外的分割次数。</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> {</span>
<span class="hljs-keyword">public</span>:
    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&gt; pre;
    <span class="hljs-keyword">int</span> n;
    
    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">minCut</span><span class="hljs-params">(<span class="hljs-built_in">string</span> s)</span> </span>{
        n=s.size();
        <span class="hljs-keyword">if</span>(n==<span class="hljs-number">1</span>)<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
        pre.assign(n,<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;(n,<span class="hljs-literal">true</span>));
        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=n<span class="hljs-number">-1</span>;i&gt;=<span class="hljs-number">0</span>;i--)
        {
            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=i+<span class="hljs-number">1</span>;j&lt;n;j++)
            {
                pre[i][j]=(s[i]==s[j]&amp;&amp;pre[i+<span class="hljs-number">1</span>][j<span class="hljs-number">-1</span>]);
            }
        }
        <span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">ans</span><span class="hljs-params">(n,INT_LEAST32_MAX)</span></span>;
        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)
        {
            <span class="hljs-keyword">if</span>(pre[<span class="hljs-number">0</span>][i])
            {
                ans[i]=<span class="hljs-number">0</span>;
            }
            <span class="hljs-keyword">else</span>
            {
                <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">0</span>;j&lt;i;j++)
                {
                    <span class="hljs-comment">//若有最后一个回文子串</span>
                    <span class="hljs-keyword">if</span>(pre[j+<span class="hljs-number">1</span>][i])
                    {
                        ans[i]=min(ans[i],ans[j]+<span class="hljs-number">1</span>);
                    }
                }
            }
        }
        <span class="hljs-keyword">return</span> ans[n<span class="hljs-number">-1</span>];
    }
};
</div></code></pre>
<h2 id="202139">2021.3.9</h2>
<h3 id="1047删除字符串中的所有相邻重复项栈字符串">1047.删除字符串中的所有相邻重复项(栈、字符串)</h3>
<p><a href="https://leetcode-cn.com/problems/remove-all-adjacent-duplicates-in-string/">删除字符串中的所有相邻重复项</a></p>
<pre><code class="language-c++"><div><span class="hljs-comment">//1047.删除字符串中的所有相邻重复项</span>
<span class="hljs-comment">//2021.3.9</span>
<span class="hljs-comment">//1.用stack容器</span>
<span class="hljs-comment">// class Solution {</span>
<span class="hljs-comment">// public:</span>
<span class="hljs-comment">//     stack&lt;int&gt; st;</span>
<span class="hljs-comment">//     string removeDuplicates(string S) {</span>
<span class="hljs-comment">//         int i=0;</span>
<span class="hljs-comment">//         while(i&lt;S.size())</span>
<span class="hljs-comment">//         {</span>
<span class="hljs-comment">//             if(!st.empty() &amp;&amp; S[st.top()]==S[i])</span>
<span class="hljs-comment">//             {</span>
<span class="hljs-comment">//                 S.erase(st.top(),2);</span>
<span class="hljs-comment">//                 st.pop();</span>
<span class="hljs-comment">//                 i--;</span>
<span class="hljs-comment">//             }</span>
<span class="hljs-comment">//             else</span>
<span class="hljs-comment">//             {</span>
<span class="hljs-comment">//                 st.push(i);</span>
<span class="hljs-comment">//                 i++;</span>
<span class="hljs-comment">//             }</span>
<span class="hljs-comment">//         }</span>
<span class="hljs-comment">//         return S;</span>
<span class="hljs-comment">//     }</span>
<span class="hljs-comment">// };</span>
<span class="hljs-comment">//2.由于 std::string 类本身就提供了类似「入栈」和「出栈」的接口，因此我们直接将需要被返回的字符串作为栈即可。</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> {</span>
<span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-built_in">string</span> <span class="hljs-title">removeDuplicates</span><span class="hljs-params">(<span class="hljs-built_in">string</span> S)</span> </span>{
        <span class="hljs-built_in">string</span> stk;
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">char</span> ch : S) {
            <span class="hljs-keyword">if</span> (!stk.empty() &amp;&amp; stk.back() == ch) 
            {
                stk.pop_back();
            } 
            <span class="hljs-keyword">else</span> 
            {
                stk.push_back(ch);
            }
        }
        <span class="hljs-keyword">return</span> stk;
    }
};
</div></code></pre>
<h2 id="2021310">2021.3.10</h2>
<h3 id="224基本计算器栈">224.基本计算器(栈)</h3>
<p><a href="https://leetcode-cn.com/problems/basic-calculator/">基本计算器</a></p>
<pre><code class="language-c++"><div><span class="hljs-comment">//224.基本计算器</span>
<span class="hljs-comment">//2021.3.10</span>
<span class="hljs-comment">//括号展开+栈</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> {</span>
<span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">calculate</span><span class="hljs-params">(<span class="hljs-built_in">string</span> s)</span> </span>{
        <span class="hljs-built_in">stack</span>&lt;<span class="hljs-keyword">int</span>&gt; ops;
        <span class="hljs-keyword">int</span> ans=<span class="hljs-number">0</span>;
        <span class="hljs-keyword">int</span> sign=<span class="hljs-number">1</span>;
        ops.push(<span class="hljs-number">1</span>);
        <span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;
        <span class="hljs-keyword">int</span> n=s.size();
        <span class="hljs-keyword">while</span>(i&lt;n)
        {
            <span class="hljs-keyword">if</span> (s[i] == <span class="hljs-string">&#x27; &#x27;</span>) {
                i++;
            } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (s[i] == <span class="hljs-string">&#x27;+&#x27;</span>) {
                sign = ops.top();
                i++;
            } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (s[i] == <span class="hljs-string">&#x27;-&#x27;</span>) {
                sign = -ops.top();
                i++;
            } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (s[i] == <span class="hljs-string">&#x27;(&#x27;</span>) {
                ops.push(sign);
                i++;
            } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (s[i] == <span class="hljs-string">&#x27;)&#x27;</span>) {
                ops.pop();
                i++;
            } <span class="hljs-keyword">else</span> {
                <span class="hljs-keyword">long</span> num = <span class="hljs-number">0</span>;
                <span class="hljs-comment">//可能有连续几位数</span>
                <span class="hljs-keyword">while</span> (i &lt; n &amp;&amp; s[i] &gt;= <span class="hljs-string">&#x27;0&#x27;</span> &amp;&amp; s[i] &lt;= <span class="hljs-string">&#x27;9&#x27;</span>) {
                    num = num * <span class="hljs-number">10</span> + s[i] - <span class="hljs-string">&#x27;0&#x27;</span>;
                    i++;
                }
                ans += sign * num;
            }
        }
        <span class="hljs-keyword">return</span> ans;
    }
};
</div></code></pre>
<h2 id="2021311">2021.3.11</h2>
<h3 id="227基本计算器栈">227.基本计算器||(栈)</h3>
<p><a href="https://leetcode-cn.com/problems/basic-calculator-ii/">基本计算器||</a></p>
<pre><code class="language-c++"><div><span class="hljs-comment">//227.基本计算器||</span>
<span class="hljs-comment">//2021.3.11</span>
<span class="hljs-comment">//栈</span>
<span class="hljs-comment">//1+2-3*4</span>
<span class="hljs-comment">//前置符号+ 数字入栈 - 相反数入栈 */直接与栈顶元素计算</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> {</span>
<span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">calculate</span><span class="hljs-params">(<span class="hljs-built_in">string</span> s)</span> </span>{
        <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; temp;
        <span class="hljs-keyword">char</span> prechar=<span class="hljs-string">&#x27;+&#x27;</span>;
        <span class="hljs-keyword">int</span> num=<span class="hljs-number">0</span>;
        <span class="hljs-keyword">int</span> n=s.size();
        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)
        {
            <span class="hljs-keyword">if</span>(<span class="hljs-built_in">isdigit</span>(s[i]))
            {
                <span class="hljs-comment">//连续数字处理</span>
                num=num*<span class="hljs-number">10</span>+<span class="hljs-keyword">int</span>(s[i]-<span class="hljs-string">&#x27;0&#x27;</span>);
            }
            <span class="hljs-keyword">if</span>(!<span class="hljs-built_in">isdigit</span>(s[i]) &amp;&amp; s[i]!=<span class="hljs-string">&#x27; &#x27;</span> || i==n<span class="hljs-number">-1</span>)
            {
                <span class="hljs-keyword">switch</span> (prechar)
                {
                    <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;+&#x27;</span>:
                    temp.push_back(num);
                        <span class="hljs-keyword">break</span>;
                    <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;-&#x27;</span>:
                    temp.push_back(-num);
                        <span class="hljs-keyword">break</span>;
                    <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;*&#x27;</span>:
                    temp.back()*=num;
                        <span class="hljs-keyword">break</span>;
                    <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;/&#x27;</span>:
                    temp.back()/=num;
                        <span class="hljs-keyword">break</span>;
                }
                prechar=s[i];
                num=<span class="hljs-number">0</span>;
            }
        }
        <span class="hljs-keyword">return</span> accumulate(temp.begin(),temp.end(),<span class="hljs-number">0</span>);
        
    }
};
</div></code></pre>
<h2 id="2021314">2021.3.14</h2>
<h3 id="705设计哈希集合c容器">705.设计哈希集合(c++容器)</h3>
<p><a href="https://leetcode-cn.com/problems/design-hashset/">设计哈希集合</a></p>
<pre><code class="language-c++"><div><span class="hljs-comment">//705.建立哈希集合</span>
<span class="hljs-comment">//2021.3.14</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyHashSet</span> {</span>
<span class="hljs-keyword">public</span>:
    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; hashset;
    <span class="hljs-comment">/** Initialize your data structure here. */</span>
    MyHashSet() {

    }
    
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-keyword">int</span> key)</span> </span>{
        <span class="hljs-keyword">if</span>(!contains(key))
        {
            hashset.push_back(key);
        }

    }
    
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">remove</span><span class="hljs-params">(<span class="hljs-keyword">int</span> key)</span> </span>{
        <span class="hljs-keyword">if</span>(contains(key))
        {
            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> it=hashset.begin();it&lt;hashset.end();it++)
            {
                <span class="hljs-keyword">if</span>((*it)==key)
                {
                    hashset.erase(it);
                    <span class="hljs-keyword">return</span>;
                }
            }
        }
        <span class="hljs-keyword">else</span> 
        {
            <span class="hljs-keyword">return</span>;
        }
        
        
    }
    
    <span class="hljs-comment">/** Returns true if this set contains the specified element */</span>
    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">contains</span><span class="hljs-params">(<span class="hljs-keyword">int</span> key)</span> </span>{
        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> it=hashset.begin();it&lt;hashset.end();it++)
        {
            <span class="hljs-keyword">if</span>((*it)==key)
            {
                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
            }
        }
        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
    }
};

<span class="hljs-comment">/**
 * Your MyHashSet object will be instantiated and called as such:
 * MyHashSet* obj = new MyHashSet();
 * obj-&gt;add(key);
 * obj-&gt;remove(key);
 * bool param_3 = obj-&gt;contains(key);
 */</span>
</div></code></pre>
<h3 id="706设计哈希映射c容器">706.设计哈希映射(c++容器)</h3>
<p><a href="https://leetcode-cn.com/problems/design-hashmap/">设计哈希映射</a></p>
<pre><code class="language-c++"><div><span class="hljs-comment">//706.设计哈希映射</span>
<span class="hljs-comment">//2021.3.14</span>
<span class="hljs-comment">//1.vector&lt;vector&lt;int&gt;&gt;</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyHashMap</span> {</span>
<span class="hljs-keyword">public</span>:
    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&gt; hash;
    <span class="hljs-comment">/** Initialize your data structure here. */</span>
    MyHashMap() {

    }
    
    <span class="hljs-comment">/** value will always be non-negative. */</span>
    <span class="hljs-comment">//二维数组遍历法</span>
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">put</span><span class="hljs-params">(<span class="hljs-keyword">int</span> key, <span class="hljs-keyword">int</span> value)</span> </span>{
        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;hash.size();i++)
        {
            <span class="hljs-keyword">if</span>(hash[i][<span class="hljs-number">0</span>]==key)
            {
                hash[i][<span class="hljs-number">1</span>]=value;
                <span class="hljs-keyword">return</span>;
            }
        }
        <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; temp;
        temp.push_back(key);
        temp.push_back(value);
        hash.push_back(temp);
        <span class="hljs-keyword">return</span>;

    }
    
    <span class="hljs-comment">/** Returns the value to which the specified key is mapped, or -1 if this map contains no mapping for the key */</span>
    <span class="hljs-comment">//迭代器遍历法</span>
    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">get</span><span class="hljs-params">(<span class="hljs-keyword">int</span> key)</span> </span>{
        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> it=hash.begin();it&lt;hash.end();it++)
        {
            <span class="hljs-keyword">if</span>((*it).front()==key)
            {
                <span class="hljs-keyword">return</span> (*it).back();
            }
        }
        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;
    }
    
    <span class="hljs-comment">/** Removes the mapping of the specified value key if this map contains a mapping for the key */</span>
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">remove</span><span class="hljs-params">(<span class="hljs-keyword">int</span> key)</span> </span>{
        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;hash.size();i++)
        {
            <span class="hljs-keyword">if</span>(hash[i][<span class="hljs-number">0</span>]==key)
            {
                <span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&gt;::iterator it=hash.begin();
                it+=i;
                hash.erase(it);
                <span class="hljs-keyword">return</span>;
            }
        }
        <span class="hljs-keyword">return</span>;
    }
};

<span class="hljs-comment">/**
 * Your MyHashMap object will be instantiated and called as such:
 * MyHashMap* obj = new MyHashMap();
 * obj-&gt;put(key,value);
 * int param_2 = obj-&gt;get(key);
 * obj-&gt;remove(key);
 */</span>


<span class="hljs-comment">//2.vector&lt;list&lt;pair&lt;int,int&gt;&gt;&gt;</span>
<span class="hljs-comment">// class MyHashMap {</span>
<span class="hljs-comment">// private:</span>
<span class="hljs-comment">//     vector&lt;list&lt;pair&lt;int, int&gt;&gt;&gt; data;</span>
<span class="hljs-comment">//     static const int base = 769;</span>
<span class="hljs-comment">//     static int hash(int key) {</span>
<span class="hljs-comment">//         return key % base;</span>
<span class="hljs-comment">//     }</span>
<span class="hljs-comment">// public:</span>
<span class="hljs-comment">//     /** Initialize your data structure here. */</span>
<span class="hljs-comment">//     MyHashMap(): data(base) {}</span>
    
<span class="hljs-comment">//     /** value will always be non-negative. */</span>
<span class="hljs-comment">//     void put(int key, int value) {</span>
<span class="hljs-comment">//         int h = hash(key);</span>
<span class="hljs-comment">//         for (auto it = data[h].begin(); it != data[h].end(); it++) {</span>
<span class="hljs-comment">//             if ((*it).first == key) {</span>
<span class="hljs-comment">//                 (*it).second = value;</span>
<span class="hljs-comment">//                 return;</span>
<span class="hljs-comment">//             }</span>
<span class="hljs-comment">//         }</span>
<span class="hljs-comment">//         data[h].push_back(make_pair(key, value));</span>
<span class="hljs-comment">//     }</span>
    
<span class="hljs-comment">//     /** Returns the value to which the specified key is mapped, or -1 if this map contains no mapping for the key */</span>
<span class="hljs-comment">//     int get(int key) {</span>
<span class="hljs-comment">//         int h = hash(key);</span>
<span class="hljs-comment">//         for (auto it = data[h].begin(); it != data[h].end(); it++) {</span>
<span class="hljs-comment">//             if ((*it).first == key) {</span>
<span class="hljs-comment">//                 return (*it).second;</span>
<span class="hljs-comment">//             }</span>
<span class="hljs-comment">//         }</span>
<span class="hljs-comment">//         return -1;</span>
<span class="hljs-comment">//     }</span>
    
<span class="hljs-comment">//     /** Removes the mapping of the specified value key if this map contains a mapping for the key */</span>
<span class="hljs-comment">//     void remove(int key) {</span>
<span class="hljs-comment">//         int h = hash(key);</span>
<span class="hljs-comment">//         for (auto it = data[h].begin(); it != data[h].end(); it++) {</span>
<span class="hljs-comment">//             if ((*it).first == key) {</span>
<span class="hljs-comment">//                 data[h].erase(it);</span>
<span class="hljs-comment">//                 return;</span>
<span class="hljs-comment">//             }</span>
<span class="hljs-comment">//         }</span>
<span class="hljs-comment">//     }</span>
<span class="hljs-comment">// };</span>
</div></code></pre>
<h3 id="331验证二叉树的前序序列化栈计数">331.验证二叉树的前序序列化(栈、计数)</h3>
<p><a href="https://leetcode-cn.com/problems/verify-preorder-serialization-of-a-binary-tree/">验证二叉树的前序序列化</a></p>
<pre><code class="language-c++"><div><span class="hljs-comment">//331.验证二叉树的前序序列化</span>
<span class="hljs-comment">//2021.3.14</span>
<span class="hljs-comment">//1.用vector模拟stack 每个节点有两个槽位</span>
<span class="hljs-comment">//遇到空节点 将栈顶节点的槽位-1</span>
<span class="hljs-comment">//遇到正常节点 先将栈顶节点槽位-1 然后将自己push进栈 槽位为2</span>
<span class="hljs-comment">//栈顶节点槽位为0则出栈</span>
<span class="hljs-comment">//在字符串遍历完前 栈为空 或遍历完后 栈不为空 则为false</span>

<span class="hljs-comment">// class Solution {</span>
<span class="hljs-comment">// public:</span>
<span class="hljs-comment">//     bool isValidSerialization(string preorder) {</span>
<span class="hljs-comment">//         if(preorder.size()==0)return false;</span>
<span class="hljs-comment">//         int cnt=0;</span>
<span class="hljs-comment">//         for(char ch:preorder)</span>
<span class="hljs-comment">//         {</span>
<span class="hljs-comment">//             if(ch!=&#x27;,&#x27;)</span>
<span class="hljs-comment">//             {</span>
<span class="hljs-comment">//                 cnt++;</span>
<span class="hljs-comment">//             }</span>
<span class="hljs-comment">//         }</span>
<span class="hljs-comment">//         //偶数个节点是错误的</span>
<span class="hljs-comment">//         if(cnt%2==0)return false;</span>
        
<span class="hljs-comment">//         vector&lt;pair&lt;int,int&gt;&gt; v;</span>
<span class="hljs-comment">//         bool firstNum=true;</span>
<span class="hljs-comment">//         for(int i=0;i&lt;preorder.size();i++)</span>
<span class="hljs-comment">//         {</span>
<span class="hljs-comment">//             if(v.empty() &amp;&amp; i!=0)return false;</span>
<span class="hljs-comment">//             if(preorder.at(i)==&#x27;,&#x27;)continue;</span>
<span class="hljs-comment">//             else if(preorder.at(i)==&#x27;#&#x27;)</span>
<span class="hljs-comment">//             {</span>
<span class="hljs-comment">//                 v.back().second--;</span>
<span class="hljs-comment">//                 while(v.back().second&lt;=0)</span>
<span class="hljs-comment">//                 {</span>
<span class="hljs-comment">//                     v.pop_back();</span>
<span class="hljs-comment">//                 }</span>
<span class="hljs-comment">//             }</span>
<span class="hljs-comment">//             else</span>
<span class="hljs-comment">//             {</span>
<span class="hljs-comment">//                 int num=0;</span>
<span class="hljs-comment">//                 while(preorder.at(i)&gt;=&#x27;0&#x27; &amp;&amp; preorder.at(i)&lt;=&#x27;9&#x27;)</span>
<span class="hljs-comment">//                 {</span>
<span class="hljs-comment">//                     num=num*10+preorder.at(i)-&#x27;0&#x27;;</span>
<span class="hljs-comment">//                     i++;</span>
<span class="hljs-comment">//                 }</span>
<span class="hljs-comment">//                 i--;</span>
<span class="hljs-comment">//                 if(!firstNum)</span>
<span class="hljs-comment">//                 {</span>
<span class="hljs-comment">//                     v.back().second--;</span>
<span class="hljs-comment">//                 }</span>
<span class="hljs-comment">//                 else</span>
<span class="hljs-comment">//                 {</span>
<span class="hljs-comment">//                     firstNum=false;</span>
<span class="hljs-comment">//                 }</span>
                
<span class="hljs-comment">//                 v.push_back(make_pair(num,2));</span>
<span class="hljs-comment">//             }</span>
<span class="hljs-comment">//         }</span>
<span class="hljs-comment">//         if(v.empty())return true;</span>
<span class="hljs-comment">//         else return false;</span>
<span class="hljs-comment">//     }</span>
<span class="hljs-comment">// };</span>
<span class="hljs-comment">//2.计数</span>
<span class="hljs-comment">//第一种方法可看出 实际上遇到 # 槽位-1 遇到数字槽位 +1 在遍历完前槽位&lt;=0 则为false</span>
<span class="hljs-comment">//遍历完后槽位&gt;0 也为false</span>
<span class="hljs-comment">//cnt初始值设为1 这样第一个是数字 cnt+1 刚好为2 </span>
<span class="hljs-comment">//第一个是空节点 cnt-1 刚好为0 如果后面还有字符 就判断false 没有字符正常跳出循环 cnt==0 为true</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> {</span>
<span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">isValidSerialization</span><span class="hljs-params">(<span class="hljs-built_in">string</span> preorder)</span> </span>{
        <span class="hljs-keyword">int</span> cnt=<span class="hljs-number">1</span>;
        <span class="hljs-keyword">int</span> n=preorder.size();
        <span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;
       
        <span class="hljs-keyword">while</span>(i&lt;n)
        {
            <span class="hljs-keyword">if</span>(cnt&lt;=<span class="hljs-number">0</span>)<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
            <span class="hljs-keyword">if</span>(preorder.at(i)==<span class="hljs-string">&#x27;,&#x27;</span>)
            {
                i++;
            }
            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(preorder.at(i)==<span class="hljs-string">&#x27;#&#x27;</span>)
            {
                cnt--;
                i++;
            }
            <span class="hljs-keyword">else</span>
            {
                <span class="hljs-keyword">while</span>(i&lt;n &amp;&amp; (preorder.at(i)&gt;=<span class="hljs-string">&#x27;0&#x27;</span> &amp;&amp; preorder.at(i)&lt;=<span class="hljs-string">&#x27;9&#x27;</span>))
                {
                    i++;
                }
                cnt++;
            }
                
        }
        <span class="hljs-keyword">return</span> cnt==<span class="hljs-number">0</span>;

    }
};
</div></code></pre>
<h2 id="2021315">2021.3.15</h2>
<h3 id="54螺旋矩阵数组">54.螺旋矩阵(数组)</h3>
<p><a href="https://leetcode-cn.com/problems/spiral-matrix/">螺旋矩阵</a></p>
<pre><code class="language-c++"><div><span class="hljs-comment">//54.螺旋矩阵</span>
<span class="hljs-comment">//2021.3.15</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> {</span>
<span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">spiralOrder</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&gt;&amp; matrix)</span> </span>{
        <span class="hljs-keyword">int</span> row=matrix.size();
        <span class="hljs-keyword">int</span> col=matrix[<span class="hljs-number">0</span>].size();
        <span class="hljs-comment">//检测矩阵元素是否被读取</span>
        <span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; &gt; hasOut;
        hasOut.assign(row,<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;(col,<span class="hljs-number">0</span>));
        <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; ans;
        <span class="hljs-keyword">int</span> cnt=<span class="hljs-number">1</span>,i=<span class="hljs-number">0</span>,j=<span class="hljs-number">0</span>;
        <span class="hljs-comment">//方向 0-右 1-下 2-左 3-上</span>
        <span class="hljs-keyword">int</span> dir=<span class="hljs-number">0</span>;
        ans.push_back(matrix[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>]);
        hasOut[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>]=<span class="hljs-number">1</span>;
        <span class="hljs-keyword">while</span>(cnt&lt;(row*col))
        {
            <span class="hljs-keyword">switch</span> (dir)
            {
                <span class="hljs-comment">//向右</span>
            <span class="hljs-keyword">case</span> <span class="hljs-number">0</span>:
            <span class="hljs-comment">//检测是否超出边界 或者 该方向上下一个数已取出</span>
                <span class="hljs-keyword">if</span>((j+<span class="hljs-number">1</span>)&gt;=col || hasOut[i][j+<span class="hljs-number">1</span>]==<span class="hljs-number">1</span>)
                {
                    dir=(dir+<span class="hljs-number">1</span>)%<span class="hljs-number">4</span>;
                }
                <span class="hljs-keyword">else</span>
                {
                    ans.push_back(matrix[i][++j]);
                    hasOut[i][j]=<span class="hljs-number">1</span>;
                    cnt++;
                }
                <span class="hljs-keyword">break</span>;
                <span class="hljs-comment">//向下</span>
            <span class="hljs-keyword">case</span> <span class="hljs-number">1</span>:
                <span class="hljs-keyword">if</span>((i+<span class="hljs-number">1</span>)&gt;=row || hasOut[i+<span class="hljs-number">1</span>][j]==<span class="hljs-number">1</span>)
                {
                    dir=(dir+<span class="hljs-number">1</span>)%<span class="hljs-number">4</span>;
                }
                <span class="hljs-keyword">else</span>
                {
                    ans.push_back(matrix[++i][j]);
                    hasOut[i][j]=<span class="hljs-number">1</span>;
                    cnt++;
                }
                <span class="hljs-keyword">break</span>;
                <span class="hljs-comment">//向左</span>
            <span class="hljs-keyword">case</span> <span class="hljs-number">2</span>:
                <span class="hljs-keyword">if</span>((j<span class="hljs-number">-1</span>)&lt;<span class="hljs-number">0</span> || hasOut[i][j<span class="hljs-number">-1</span>]==<span class="hljs-number">1</span>)
                {
                    dir=(dir+<span class="hljs-number">1</span>)%<span class="hljs-number">4</span>;
                }
                <span class="hljs-keyword">else</span>
                {
                    ans.push_back(matrix[i][--j]);
                    hasOut[i][j]=<span class="hljs-number">1</span>;
                    cnt++;
                }
                <span class="hljs-keyword">break</span>;
                <span class="hljs-comment">//向上</span>
            <span class="hljs-keyword">case</span> <span class="hljs-number">3</span>:
                <span class="hljs-keyword">if</span>((i<span class="hljs-number">-1</span>)&lt;<span class="hljs-number">0</span> || hasOut[i<span class="hljs-number">-1</span>][j]==<span class="hljs-number">1</span>)
                {
                    dir=(dir+<span class="hljs-number">1</span>)%<span class="hljs-number">4</span>;
                }
                <span class="hljs-keyword">else</span>
                {
                    ans.push_back(matrix[--i][j]);
                    hasOut[i][j]=<span class="hljs-number">1</span>;
                    cnt++;
                }
                <span class="hljs-keyword">break</span>;
            }
        }
        <span class="hljs-keyword">return</span> ans;
    }
};
</div></code></pre>
<h2 id="2021316">2021.3.16</h2>
<h3 id="59螺旋矩阵数组">59.螺旋矩阵||(数组)</h3>
<p><a href="https://leetcode-cn.com/problems/spiral-matrix-ii/">螺旋矩阵||</a></p>
<pre><code class="language-c++"><div><span class="hljs-comment">//59.螺旋矩阵||</span>
<span class="hljs-comment">//2021.3.16</span>

<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> {</span>
<span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&gt; <span class="hljs-title">generateMatrix</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>{
        <span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&gt; ans;
        ans.assign(n,<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;(n,<span class="hljs-number">-1</span>));
        <span class="hljs-keyword">int</span> cnt=<span class="hljs-number">1</span>,i=<span class="hljs-number">0</span>,j=<span class="hljs-number">0</span>;
        <span class="hljs-comment">//方向 0-右 1-下 2-左 3-上</span>
        <span class="hljs-keyword">int</span> dir=<span class="hljs-number">0</span>;
        ans[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>]=<span class="hljs-number">1</span>;
        <span class="hljs-keyword">while</span>(cnt&lt;(n*n))
        {
            <span class="hljs-keyword">switch</span> (dir)
            {
                <span class="hljs-comment">//向右</span>
            <span class="hljs-keyword">case</span> <span class="hljs-number">0</span>:
            <span class="hljs-comment">//检测是否超出边界 或者 该方向上下一个数已赋值</span>
                <span class="hljs-keyword">if</span>((j+<span class="hljs-number">1</span>)&gt;=n || ans[i][j+<span class="hljs-number">1</span>]!=<span class="hljs-number">-1</span>)
                {
                    dir=(dir+<span class="hljs-number">1</span>)%<span class="hljs-number">4</span>;
                }
                <span class="hljs-keyword">else</span>
                {
                    cnt++;
                    ans[i][++j]=cnt;
                }
                <span class="hljs-keyword">break</span>;
                <span class="hljs-comment">//向下</span>
            <span class="hljs-keyword">case</span> <span class="hljs-number">1</span>:
                <span class="hljs-keyword">if</span>((i+<span class="hljs-number">1</span>)&gt;=n || ans[i+<span class="hljs-number">1</span>][j]!=<span class="hljs-number">-1</span>)
                {
                    dir=(dir+<span class="hljs-number">1</span>)%<span class="hljs-number">4</span>;
                }
                <span class="hljs-keyword">else</span>
                {
                    cnt++;
                    ans[++i][j]=cnt;
                }
                <span class="hljs-keyword">break</span>;
                <span class="hljs-comment">//向左</span>
            <span class="hljs-keyword">case</span> <span class="hljs-number">2</span>:
                <span class="hljs-keyword">if</span>((j<span class="hljs-number">-1</span>)&lt;<span class="hljs-number">0</span> || ans[i][j<span class="hljs-number">-1</span>]!=<span class="hljs-number">-1</span>)
                {
                    dir=(dir+<span class="hljs-number">1</span>)%<span class="hljs-number">4</span>;
                }
                <span class="hljs-keyword">else</span>
                {
                    cnt++;
                    ans[i][--j]=cnt;
                }
                <span class="hljs-keyword">break</span>;
                <span class="hljs-comment">//向上</span>
            <span class="hljs-keyword">case</span> <span class="hljs-number">3</span>:
                <span class="hljs-keyword">if</span>((i<span class="hljs-number">-1</span>)&lt;<span class="hljs-number">0</span> || ans[i<span class="hljs-number">-1</span>][j]!=<span class="hljs-number">-1</span>)
                {
                    dir=(dir+<span class="hljs-number">1</span>)%<span class="hljs-number">4</span>;
                }
                <span class="hljs-keyword">else</span>
                {
                    cnt++;
                    ans[--i][j]=cnt;
                }
                <span class="hljs-keyword">break</span>;
            }
        }
        <span class="hljs-keyword">return</span> ans;
    }
};
</div></code></pre>
<h2 id="2021317">2021.3.17</h2>
<h3 id="115不同的子序列动态规划">115.不同的子序列(动态规划)</h3>
<p><a href="https://leetcode-cn.com/problems/distinct-subsequences/">不同的子序列</a></p>
<pre><code class="language-c++"><div><span class="hljs-comment">//115.不同的子序列</span>
<span class="hljs-comment">//2021.3.17</span>
<span class="hljs-comment">//1.深度优先搜索 时On2</span>
<span class="hljs-comment">// class Solution {</span>
<span class="hljs-comment">// public:</span>
<span class="hljs-comment">//     int ans=0;</span>
<span class="hljs-comment">//     void dfs(string s, string t)</span>
<span class="hljs-comment">//     {</span>
<span class="hljs-comment">//         for(int i=0;i&lt;s.size();i++)</span>
<span class="hljs-comment">//         {</span>
<span class="hljs-comment">//             if(s[i]==t[0])</span>
<span class="hljs-comment">//             {</span>
<span class="hljs-comment">//                 //若已找到t的最后一个字符</span>
<span class="hljs-comment">//                 if(t.size()==1)</span>
<span class="hljs-comment">//                 {</span>
<span class="hljs-comment">//                     ans++;</span>
<span class="hljs-comment">//                 }</span>
<span class="hljs-comment">//                 else</span>
<span class="hljs-comment">//                 {</span>
<span class="hljs-comment">//                     dfs(s.substr(i+1),t.substr(1));</span>
<span class="hljs-comment">//                 }</span>
<span class="hljs-comment">//              }</span>
<span class="hljs-comment">//         }</span>
<span class="hljs-comment">//         return;</span>
<span class="hljs-comment">//     }</span>
<span class="hljs-comment">//     int numDistinct(string s, string t) {</span>
<span class="hljs-comment">//         dfs(s,t);</span>
<span class="hljs-comment">//         return ans;</span>
<span class="hljs-comment">//     }</span>
<span class="hljs-comment">// };</span>
<span class="hljs-comment">//2.动态规划</span>
<span class="hljs-comment">//从后往前遍历</span>
<span class="hljs-comment">//sch==tch dp[i][j]=dp[i+1][j+1]+dp[i+1][j]</span>
<span class="hljs-comment">//sch!=tch dp[i][j]=dp[i+1][j]</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> {</span>
<span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">numDistinct</span><span class="hljs-params">(<span class="hljs-built_in">string</span> s, <span class="hljs-built_in">string</span> t)</span> </span>{
        <span class="hljs-keyword">int</span> m=s.size(),n=t.size();
        <span class="hljs-keyword">if</span>(m&lt;n)<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
        <span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">long</span>&gt;&gt; <span class="hljs-title">dp</span><span class="hljs-params">(m+<span class="hljs-number">1</span>,<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">long</span>&gt;(n+<span class="hljs-number">1</span>))</span></span>;
        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;=m;i++)
        {
            dp[i][n]=<span class="hljs-number">1</span>;
        }
        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=m<span class="hljs-number">-1</span>;i&gt;=<span class="hljs-number">0</span>;i--)
        {
            <span class="hljs-keyword">char</span> sch=s.at(i);
            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=n<span class="hljs-number">-1</span>;j&gt;=<span class="hljs-number">0</span>;j--)
            {
                <span class="hljs-keyword">char</span> tch=t.at(j);
                <span class="hljs-keyword">if</span>(sch == tch)
                {
                    dp[i][j]=dp[i+<span class="hljs-number">1</span>][j+<span class="hljs-number">1</span>]+dp[i+<span class="hljs-number">1</span>][j];
                }
                <span class="hljs-keyword">else</span>
                {
                    dp[i][j]=dp[i+<span class="hljs-number">1</span>][j];
                }
            }
        }
        <span class="hljs-keyword">return</span> dp[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>];
    }
};
</div></code></pre>
<h2 id="2021318">2021.3.18</h2>
<h3 id="92反转链表链表">92.反转链表||(链表)</h3>
<p><a href="https://leetcode-cn.com/problems/reverse-linked-list-ii/">反转链表||</a></p>
<pre><code class="language-c++"><div><span class="hljs-comment">//92.反转链表||</span>
<span class="hljs-comment">//2021.3.18</span>
<span class="hljs-comment">//一次遍历 头插法</span>
<span class="hljs-comment">//具体看官网动画</span>
<span class="hljs-comment">//Definition for singly-linked list.</span>
<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ListNode</span> {</span>
    <span class="hljs-keyword">int</span> val;
    ListNode *next;
    ListNode() : val(<span class="hljs-number">0</span>), next(<span class="hljs-literal">nullptr</span>) {}
    ListNode(<span class="hljs-keyword">int</span> x) : val(x), next(<span class="hljs-literal">nullptr</span>) {}
    ListNode(<span class="hljs-keyword">int</span> x, ListNode *next) : val(x), next(next) {}
};
 
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> {</span>
<span class="hljs-keyword">public</span>:
    <span class="hljs-function">ListNode* <span class="hljs-title">reverseBetween</span><span class="hljs-params">(ListNode* head, <span class="hljs-keyword">int</span> left, <span class="hljs-keyword">int</span> right)</span> </span>{
        ListNode *dummyNode=<span class="hljs-keyword">new</span> ListNode(<span class="hljs-number">-1</span>);
        dummyNode-&gt;next=head;
        ListNode *pre=dummyNode;
        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;left<span class="hljs-number">-1</span>;i++)
        {
            pre=pre-&gt;next;
        }
        ListNode *cur=pre-&gt;next;
        ListNode *next;
        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;right-left;i++)
        {
            next=cur-&gt;next;
            cur-&gt;next=next-&gt;next;
            next-&gt;next=pre-&gt;next;
            pre-&gt;next=next;
        }
        <span class="hljs-keyword">return</span> dummyNode-&gt;next;
    }
};
</div></code></pre>
<h2 id="2021319">2021.3.19</h2>
<h3 id="1603设计停车系统简单题">1603.设计停车系统(简单题)</h3>
<p><a href="https://leetcode-cn.com/problems/design-parking-system/">设计停车系统</a></p>
<pre><code class="language-c++"><div><span class="hljs-comment">//1603.设计停车系统</span>
<span class="hljs-comment">//2021.3.19</span>
<span class="hljs-comment">//太简单了 没必要多说</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ParkingSystem</span> {</span>
<span class="hljs-keyword">public</span>:
    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; park;
    ParkingSystem(<span class="hljs-keyword">int</span> big, <span class="hljs-keyword">int</span> medium, <span class="hljs-keyword">int</span> small) {
        park.assign(<span class="hljs-number">4</span>,<span class="hljs-number">0</span>);
        park[<span class="hljs-number">1</span>]=big;
        park[<span class="hljs-number">2</span>]=medium;
        park[<span class="hljs-number">3</span>]=small;
    }
    
    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">addCar</span><span class="hljs-params">(<span class="hljs-keyword">int</span> carType)</span> </span>{
        <span class="hljs-keyword">if</span>(park[carType]&gt;<span class="hljs-number">0</span>)
        {
            park[carType]--;
            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
        }
        <span class="hljs-keyword">else</span>
        {
            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
        }
    }
};

<span class="hljs-comment">/**
 * Your ParkingSystem object will be instantiated and called as such:
 * ParkingSystem* obj = new ParkingSystem(big, medium, small);
 * bool param_1 = obj-&gt;addCar(carType);
 */</span>
</div></code></pre>
<h3 id="217存在重复元素哈希集合">217.存在重复元素(哈希集合)</h3>
<p><a href="https://leetcode-cn.com/problems/contains-duplicate/">存在重复元素</a></p>
<pre><code class="language-c++"><div><span class="hljs-comment">//217.存在重复元素</span>
<span class="hljs-comment">//2021.3.19</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> {</span>
<span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">containsDuplicate</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums)</span> </span>{
        <span class="hljs-built_in">unordered_set</span>&lt;<span class="hljs-keyword">int</span>&gt; has;
        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;nums.size();i++)
        {
            <span class="hljs-keyword">if</span>(has.find(nums[i])!=has.end())<span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
            <span class="hljs-keyword">else</span> has.insert(nums[i]);
        }        
        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
    }
};
</div></code></pre>
<h2 id="2021320">2021.3.20</h2>
<h3 id="150逆波兰表达式求值栈">150.逆波兰表达式求值(栈)</h3>
<p><a href="https://leetcode-cn.com/problems/evaluate-reverse-polish-notation/">逆波兰表达式求值</a></p>
<pre><code class="language-c++"><div><span class="hljs-comment">//150.逆波兰表达式求值</span>
<span class="hljs-comment">//2021.3.20</span>
<span class="hljs-comment">//1.栈 碰到数字入栈 碰到运算符 连续两个数字出栈 再将结果入栈</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> {</span>
<span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">evalRPN</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">string</span>&gt;&amp; tokens)</span> </span>{
        <span class="hljs-built_in">stack</span>&lt;<span class="hljs-keyword">int</span>&gt; st;
        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;tokens.size();i++)
        {
            <span class="hljs-keyword">if</span>(tokens[i]==<span class="hljs-string">&quot;+&quot;</span>)
            {
                <span class="hljs-keyword">int</span> num2=st.top();
                st.pop();
                <span class="hljs-keyword">int</span> num1=st.top();
                st.pop();
                <span class="hljs-keyword">int</span> ans=num1+num2;
                st.push(ans);
            }
            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(tokens[i]==<span class="hljs-string">&quot;-&quot;</span>)
            {
                <span class="hljs-keyword">int</span> num2=st.top();
                st.pop();
                <span class="hljs-keyword">int</span> num1=st.top();
                st.pop();
                <span class="hljs-keyword">int</span> ans=num1-num2;
                st.push(ans);
            }
            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(tokens[i]==<span class="hljs-string">&quot;*&quot;</span>)
            {
                <span class="hljs-keyword">int</span> num2=st.top();
                st.pop();
                <span class="hljs-keyword">int</span> num1=st.top();
                st.pop();
                <span class="hljs-keyword">int</span> ans=num1*num2;
                st.push(ans);
            }
            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(tokens[i]==<span class="hljs-string">&quot;/&quot;</span>)
            {
                <span class="hljs-keyword">int</span> num2=st.top();
                st.pop();
                <span class="hljs-keyword">int</span> num1=st.top();
                st.pop();
                <span class="hljs-keyword">int</span> ans=num1/num2;
                st.push(ans);
            }
            <span class="hljs-keyword">else</span>
            {
                <span class="hljs-keyword">int</span> num=<span class="hljs-number">0</span>,sign=<span class="hljs-number">1</span>;
                <span class="hljs-keyword">for</span>(<span class="hljs-keyword">char</span> ch:tokens[i])
                {
                    <span class="hljs-keyword">if</span>(ch==<span class="hljs-string">&#x27;-&#x27;</span>)
                    {
                        sign=<span class="hljs-number">-1</span>;
                    }
                    <span class="hljs-keyword">else</span>
                    {
                        num=num*<span class="hljs-number">10</span>+ch-<span class="hljs-string">&#x27;0&#x27;</span>;
                    }
                }
                num*=sign;
                st.push(num);
            }
        }
        <span class="hljs-keyword">return</span> st.top();
    }
};
</div></code></pre>
<h2 id="2021321">2021.3.21</h2>
<h3 id="73矩阵置零矩阵原地算法">73.矩阵置零(矩阵、原地算法)</h3>
<h4 id="原地算法">原地算法</h4>
<p>在计算机科学中，一个原地算法（in-place algorithm）是一种使用小的，固定数量的额外之空间来转换资料的算法。当算法执行时，输入的资料通常会被要输出的部份覆盖掉。不是原地算法有时候称为非原地（not-in-place）或不得其所（out-of-place）。<br>
<a href="https://leetcode-cn.com/problems/set-matrix-zeroes/">矩阵置零</a></p>
<pre><code class="language-c++"><div><span class="hljs-comment">//73.矩阵置零</span>
<span class="hljs-comment">//2021.3.21</span>
<span class="hljs-comment">//列置零时遇到本来就是0的就在那个位置开始行置零</span>
<span class="hljs-comment">//行置零时就列置零</span>
<span class="hljs-comment">//相当于递归 会栈溢出</span>
<span class="hljs-comment">// class Solution {</span>
<span class="hljs-comment">// public:</span>
<span class="hljs-comment">//     void setZeroes(vector&lt;vector&lt;int&gt;&gt;&amp; matrix) {</span>
<span class="hljs-comment">//         for(int i=0;i&lt;matrix.size();i++)</span>
<span class="hljs-comment">//         {</span>
<span class="hljs-comment">//             for(int j=0;j&lt;matrix[0].size();j++)</span>
<span class="hljs-comment">//             {</span>
<span class="hljs-comment">//                 if(matrix[i][j]==0)</span>
<span class="hljs-comment">//                 {</span>
<span class="hljs-comment">//                     setColZeros(matrix,i,j);</span>
<span class="hljs-comment">//                     setRowZeros(matrix,i,j);</span>
<span class="hljs-comment">//                     return;</span>
<span class="hljs-comment">//                 }</span>
<span class="hljs-comment">//             }</span>
<span class="hljs-comment">//         }</span>
<span class="hljs-comment">//     }</span>
<span class="hljs-comment">//     void setColZeros(vector&lt;vector&lt;int&gt;&gt;&amp; matrix ,int row,int col)</span>
<span class="hljs-comment">//     {</span>
<span class="hljs-comment">//         int rowDe=row;</span>
<span class="hljs-comment">//         int rowIn=row;</span>
<span class="hljs-comment">//         while(rowDe&gt;=0 || rowIn&lt;matrix.size())</span>
<span class="hljs-comment">//         {</span>
<span class="hljs-comment">//             if(matrix[rowDe][col]==0)</span>
<span class="hljs-comment">//             {</span>
<span class="hljs-comment">//                 setRowZeros(matrix,rowDe,col);</span>
<span class="hljs-comment">//             }</span>
<span class="hljs-comment">//             if(matrix[rowIn][col]==0)</span>
<span class="hljs-comment">//             {</span>
<span class="hljs-comment">//                 setRowZeros(matrix,rowIn,col);</span>
<span class="hljs-comment">//             }</span>
<span class="hljs-comment">//             matrix[rowDe][col] = 0;</span>
<span class="hljs-comment">//             matrix[rowIn][col] = 0;</span>
<span class="hljs-comment">//             rowDe--;</span>
<span class="hljs-comment">//             rowIn++;</span>
<span class="hljs-comment">//         }</span>
<span class="hljs-comment">//     }</span>
<span class="hljs-comment">//     void setRowZeros(vector&lt;vector&lt;int&gt;&gt;&amp; matrix ,int row,int col)</span>
<span class="hljs-comment">//     {</span>
<span class="hljs-comment">//         int colDe=col;</span>
<span class="hljs-comment">//         int colIn=col;</span>
<span class="hljs-comment">//         while(colDe&gt;=0 || colIn&lt;matrix[0].size())</span>
<span class="hljs-comment">//         {</span>
<span class="hljs-comment">//             if(matrix[row][colDe]==0)</span>
<span class="hljs-comment">//             {</span>
<span class="hljs-comment">//                 setColZeros(matrix,row,colDe);</span>
<span class="hljs-comment">//             }</span>
<span class="hljs-comment">//             if(matrix[row][colIn]==0)</span>
<span class="hljs-comment">//             {</span>
<span class="hljs-comment">//                 setColZeros(matrix,row,colIn);</span>
<span class="hljs-comment">//             }</span>
<span class="hljs-comment">//             matrix[row][colDe] = 0;</span>
<span class="hljs-comment">//             matrix[row][colIn] = 0;</span>
<span class="hljs-comment">//             colDe--;</span>
<span class="hljs-comment">//             colIn++;</span>
<span class="hljs-comment">//         }</span>
<span class="hljs-comment">//     }</span>
<span class="hljs-comment">// };</span>
<span class="hljs-comment">//2.双标志位 时Omn 空O1</span>
<span class="hljs-comment">//第一行和第一列用来标记该行/列中有无0 至于第一行/列本身用两个标志</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> {</span>
<span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">setZeroes</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&gt;&amp; matrix)</span> </span>{
        <span class="hljs-keyword">int</span> row0Flag=<span class="hljs-literal">false</span>,col0Flag=<span class="hljs-literal">false</span>;
        <span class="hljs-keyword">int</span> row=matrix.size(),col=matrix[<span class="hljs-number">0</span>].size();
        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;col;i++)
        {
            <span class="hljs-keyword">if</span>(matrix[<span class="hljs-number">0</span>][i] == <span class="hljs-number">0</span>)
            {
                row0Flag=<span class="hljs-literal">true</span>;
                <span class="hljs-keyword">break</span>;
            }
        }
        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;row;i++)
        {
            <span class="hljs-keyword">if</span>(matrix[i][<span class="hljs-number">0</span>] == <span class="hljs-number">0</span>)
            {
                col0Flag=<span class="hljs-literal">true</span>;
                <span class="hljs-keyword">break</span>;
            }
        }
        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;row;i++)
        {
            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">1</span>;j&lt;col;j++)
            {
                <span class="hljs-keyword">if</span>(matrix[i][j] == <span class="hljs-number">0</span>)
                {
                    matrix[i][<span class="hljs-number">0</span>]=matrix[<span class="hljs-number">0</span>][j]=<span class="hljs-number">0</span>;
                }
            }
        }
        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;row;i++)
        {
            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">1</span>;j&lt;col;j++)
            {
                <span class="hljs-keyword">if</span>(matrix[i][<span class="hljs-number">0</span>] == <span class="hljs-number">0</span> || matrix[<span class="hljs-number">0</span>][j] == <span class="hljs-number">0</span>)
                {
                    matrix[i][j]=<span class="hljs-number">0</span>;
                }
            }
        }
        <span class="hljs-keyword">if</span>(row0Flag)
        {
            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;col;i++)
            {
                matrix[<span class="hljs-number">0</span>][i]=<span class="hljs-number">0</span>;
            }
        }
        <span class="hljs-keyword">if</span>(col0Flag)
        {
            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;row;i++)
            {
                matrix[i][<span class="hljs-number">0</span>]=<span class="hljs-number">0</span>;
            }
        }
    }
};
</div></code></pre>
<h2 id="2021322">2021.3.22</h2>
<h3 id="191位1的个数位运算">191.位1的个数(位运算)</h3>
<p><a href="https://leetcode-cn.com/problems/number-of-1-bits/">位1的个数</a></p>
<pre><code class="language-c++"><div><span class="hljs-comment">//191.位1的个数</span>
<span class="hljs-comment">//2021.3.22</span>
<span class="hljs-comment">//让 n与 2^i2 进行与运算，当且仅当 n 的第 i 位为 1 时，运算结果不为 0</span>
<span class="hljs-comment">// class Solution {</span>
<span class="hljs-comment">// public:</span>
<span class="hljs-comment">//     int hammingWeight(uint32_t n) {</span>
<span class="hljs-comment">//         int cnt = 0;</span>
<span class="hljs-comment">//         for(int i=0;i&lt;32;i++)</span>
<span class="hljs-comment">//         {</span>
<span class="hljs-comment">//             if(n &amp; (1&lt;&lt;i))</span>
<span class="hljs-comment">//             {</span>
<span class="hljs-comment">//                 cnt++;</span>
<span class="hljs-comment">//             }</span>
<span class="hljs-comment">//         }</span>
<span class="hljs-comment">//         return cnt;</span>
<span class="hljs-comment">//     }</span>
<span class="hljs-comment">// };</span>
<span class="hljs-comment">//n &amp; (n−1)，其预算结果恰为把 n 的二进制位中的最低位的 1 变为 0 之后的结果</span>
<span class="hljs-comment">//6&amp;(6-1) = 4, 6 = (110), 4 = (100) </span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> {</span>
<span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">hammingWeight</span><span class="hljs-params">(<span class="hljs-keyword">uint32_t</span> n)</span> </span>{
        <span class="hljs-keyword">int</span> cnt = <span class="hljs-number">0</span>;
        <span class="hljs-keyword">while</span>(n)
        {
            n=n&amp;(n<span class="hljs-number">-1</span>);
            cnt++;
        }
        <span class="hljs-keyword">return</span> cnt;
    }
};
</div></code></pre>
<h2 id="2021323">2021.3.23</h2>
<h3 id="341扁平化嵌套列表迭代器深度优先搜索">341.扁平化嵌套列表迭代器(深度优先搜索)</h3>
<p><a href="https://leetcode-cn.com/problems/flatten-nested-list-iterator/">扁平化嵌套列表迭代器</a></p>
<pre><code class="language-c++"><div><span class="hljs-comment">//341.扁平化嵌套列表迭代器</span>
<span class="hljs-comment">//2021.3.23</span>
<span class="hljs-comment">//深度优先搜索</span>
<span class="hljs-comment">// This is the interface that allows for creating nested lists.</span>
<span class="hljs-comment">// You should not implement it, or speculate about its implementation</span>
 <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NestedInteger</span> {</span>
    <span class="hljs-keyword">public</span>:
     <span class="hljs-comment">// Return true if this NestedInteger holds a single integer, rather than a nested list.</span>
      <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">isInteger</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span></span>;
 
      <span class="hljs-comment">// Return the single integer that this NestedInteger holds, if it holds a single integer</span>
      <span class="hljs-comment">// The result is undefined if this NestedInteger holds a nested list</span>
      <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">getInteger</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span></span>;
 
      <span class="hljs-comment">// Return the nested list that this NestedInteger holds, if it holds a nested list</span>
      <span class="hljs-comment">// The result is undefined if this NestedInteger holds a single integer</span>
      <span class="hljs-function"><span class="hljs-keyword">const</span> <span class="hljs-built_in">vector</span>&lt;NestedInteger&gt; &amp;<span class="hljs-title">getList</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span></span>;
  };
 

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NestedIterator</span> {</span>
<span class="hljs-keyword">public</span>:
    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; vals;
    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;::iterator cur;
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-built_in">vector</span>&lt;NestedInteger&gt; &amp;nestedList)</span>
    </span>{
        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> &amp;nest:nestedList)
        {
            <span class="hljs-keyword">if</span>(nest.isInteger())
            {
                vals.push_back(nest.getInteger());
            }
            <span class="hljs-keyword">else</span>
            {
                dfs(nest.getList());
            }
        }
    }
    NestedIterator(<span class="hljs-built_in">vector</span>&lt;NestedInteger&gt; &amp;nestedList) {
        dfs(nestedList);
        cur = vals.begin();
    }
    
    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">next</span><span class="hljs-params">()</span> </span>{
        <span class="hljs-keyword">return</span> *cur++;
    }
    
    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">hasNext</span><span class="hljs-params">()</span> </span>{
        <span class="hljs-keyword">return</span> cur != vals.end();
    }
};

<span class="hljs-comment">/**
 * Your NestedIterator object will be instantiated and called as such:
 * NestedIterator i(nestedList);
 * while (i.hasNext()) cout &lt;&lt; i.next();
 */</span>
</div></code></pre>
<h2 id="2021324">2021.3.24</h2>
<h3 id="456132模式单调栈">456.132模式(单调栈)</h3>
<p><a href="https://leetcode-cn.com/problems/132-pattern/">132模式</a></p>
<pre><code class="language-c++"><div><span class="hljs-comment">//456.132模式</span>
<span class="hljs-comment">//2021.3.24</span>
<span class="hljs-comment">//双指针 左右定好后 找中间的数 若找不到 右指针移动 找到比之前的数小时 再动左指针</span>
<span class="hljs-comment">//会超时</span>
<span class="hljs-comment">// class Solution {</span>
<span class="hljs-comment">// public:</span>
<span class="hljs-comment">//     bool find132pattern(vector&lt;int&gt;&amp; nums) {</span>
<span class="hljs-comment">//         vector&lt;int&gt;::iterator left,right;</span>
<span class="hljs-comment">//         left=nums.begin();</span>
<span class="hljs-comment">//         right=nums.end();</span>
<span class="hljs-comment">//         int lastRight = INT32_MAX;</span>
<span class="hljs-comment">//         while(left&lt;right)</span>
<span class="hljs-comment">//         {</span>
<span class="hljs-comment">//             if(*right &lt; lastRight)</span>
<span class="hljs-comment">//             {</span>
<span class="hljs-comment">//                 if(*left &lt; *right)</span>
<span class="hljs-comment">//                 {</span>
<span class="hljs-comment">//                     lastRight = *right;</span>
<span class="hljs-comment">//                     for(auto middle = left+1;middle &lt; right;middle++)</span>
<span class="hljs-comment">//                     {</span>
<span class="hljs-comment">//                         if((*middle &gt; *left) &amp;&amp; (*middle &lt; *right))</span>
<span class="hljs-comment">//                         {</span>
<span class="hljs-comment">//                             return true;</span>
<span class="hljs-comment">//                         }</span>
<span class="hljs-comment">//                     }</span>
<span class="hljs-comment">//                     right--;</span>
<span class="hljs-comment">//                 }</span>
<span class="hljs-comment">//                 else</span>
<span class="hljs-comment">//                 {</span>
<span class="hljs-comment">//                     left++;</span>
<span class="hljs-comment">//                 }</span>
<span class="hljs-comment">//             }</span>
<span class="hljs-comment">//             else</span>
<span class="hljs-comment">//             {</span>
<span class="hljs-comment">//                 right--;</span>
<span class="hljs-comment">//             }</span>
<span class="hljs-comment">//         }</span>
<span class="hljs-comment">//         return false;</span>
<span class="hljs-comment">//     }</span>
<span class="hljs-comment">// };</span>
<span class="hljs-comment">//2.单调栈 栈底到栈顶严格单调递减</span>
<span class="hljs-comment">//132 {0,4,2,1} 中有042 041 021</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> {</span>
<span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">find132pattern</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums)</span> </span>{
        <span class="hljs-keyword">int</span> n = nums.size();
        <span class="hljs-built_in">stack</span>&lt;<span class="hljs-keyword">int</span>&gt; temp;
        <span class="hljs-keyword">int</span> max2=INT_MIN;
        temp.push(nums[n<span class="hljs-number">-1</span>]);
        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=n<span class="hljs-number">-2</span>;i&gt;=<span class="hljs-number">0</span>;i--)
        {
            <span class="hljs-comment">//检查该元素能否当1</span>
            <span class="hljs-keyword">if</span>(nums[i]&lt;max2)<span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
            <span class="hljs-keyword">else</span>
            {
                <span class="hljs-comment">//找出最大能当2的元素 2越大 1越容易找到</span>
                <span class="hljs-keyword">while</span>(!temp.empty() &amp;&amp; nums[i]&gt;temp.top())
                {
                    <span class="hljs-keyword">if</span>(temp.top()&gt;max2)
                    {
                        max2=temp.top();
                    }
                    temp.pop();
                }
            }
            <span class="hljs-comment">//如果当前元素没有大于当前最大2 它就没有做2的潜质</span>
            <span class="hljs-keyword">if</span>(nums[i]&gt;max2)
            {
                temp.push(nums[i]);
            }
        }
        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
    }
};
</div></code></pre>
<h2 id="2021325">2021.3.25</h2>
<h3 id="82删除排序链表中的重复元素链表">82.删除排序链表中的重复元素||(链表)</h3>
<p><a href="%E5%88%A0%E9%99%A4%E6%8E%92%E5%BA%8F%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A0%7C%7C">https://leetcode-cn.com/problems/remove-duplicates-from-sorted-list-ii/</a></p>
<pre><code class="language-c++"><div><span class="hljs-comment">//82.删除排序链表中的重复元素||</span>
<span class="hljs-comment">//2021.3.25</span>
<span class="hljs-comment">// cur.next.val == cur.next.next.val 则 cur.next = cur.next.next</span>
<span class="hljs-comment">//Definition for singly-linked list.</span>
<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ListNode</span> {</span>
    <span class="hljs-keyword">int</span> val;
    ListNode *next;
    ListNode() : val(<span class="hljs-number">0</span>), next(<span class="hljs-literal">nullptr</span>) {}
    ListNode(<span class="hljs-keyword">int</span> x) : val(x), next(<span class="hljs-literal">nullptr</span>) {}
    ListNode(<span class="hljs-keyword">int</span> x, ListNode *next) : val(x), next(next) {}
 };

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> {</span>
<span class="hljs-keyword">public</span>:
    <span class="hljs-function">ListNode* <span class="hljs-title">deleteDuplicates</span><span class="hljs-params">(ListNode* head)</span> </span>{
        <span class="hljs-keyword">if</span> (!head) {
            <span class="hljs-keyword">return</span> head;
        }
        ListNode* dummy = <span class="hljs-keyword">new</span> ListNode(<span class="hljs-number">0</span>, head);
        ListNode* cur = dummy;
        <span class="hljs-keyword">while</span> (cur-&gt;next &amp;&amp; cur-&gt;next-&gt;next) {
            <span class="hljs-keyword">if</span> (cur-&gt;next-&gt;val == cur-&gt;next-&gt;next-&gt;val) {
                <span class="hljs-keyword">int</span> x = cur-&gt;next-&gt;val;
                <span class="hljs-keyword">while</span> (cur-&gt;next &amp;&amp; cur-&gt;next-&gt;val == x) {
                    <span class="hljs-comment">//把相同元素删去</span>
                    cur-&gt;next = cur-&gt;next-&gt;next;
                }
            }
            <span class="hljs-keyword">else</span> {
                cur = cur-&gt;next;
            }
        }
        <span class="hljs-keyword">return</span> dummy-&gt;next;
    }
};
</div></code></pre>
<h2 id="2021327">2021.3.27</h2>
<h3 id="83删除排序链表中的重复元素链表">83.删除排序链表中的重复元素(链表)</h3>
<p><a href="https://leetcode-cn.com/problems/remove-duplicates-from-sorted-list/">删除排序链表中的重复元素</a></p>
<pre><code class="language-c++"><div><span class="hljs-comment">//83.删除排序链表中的重复元素</span>
<span class="hljs-comment">//2021.3.27</span>
<span class="hljs-comment">//一个前置指针 指向新出现的数 后面一个指针遍历 遇到相同 则跳过 遇到新数字 将pre赋值</span>
<span class="hljs-comment">//Definition for singly-linked list.</span>
  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ListNode</span> {</span>
      <span class="hljs-keyword">int</span> val;
      ListNode *next;
      ListNode() : val(<span class="hljs-number">0</span>), next(<span class="hljs-literal">nullptr</span>) {}
      ListNode(<span class="hljs-keyword">int</span> x) : val(x), next(<span class="hljs-literal">nullptr</span>) {}
      ListNode(<span class="hljs-keyword">int</span> x, ListNode *next) : val(x), next(next) {}
  };

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> {</span>
<span class="hljs-keyword">public</span>:
    <span class="hljs-function">ListNode* <span class="hljs-title">deleteDuplicates</span><span class="hljs-params">(ListNode* head)</span> </span>{
        <span class="hljs-keyword">if</span>(head == <span class="hljs-literal">nullptr</span> || head-&gt;next == <span class="hljs-literal">nullptr</span>)<span class="hljs-keyword">return</span> head;
        ListNode* pre;
        ListNode* cur;
        pre = head;
        cur = head-&gt;next;
        <span class="hljs-keyword">while</span>(cur != <span class="hljs-literal">nullptr</span>)
        {
            <span class="hljs-keyword">if</span>(pre-&gt;val != cur-&gt;val)
            {
                pre = cur;
                cur = cur-&gt;next;
            }
            <span class="hljs-keyword">else</span>
            {
                pre-&gt;next = cur-&gt;next;
                cur = cur-&gt;next;
            }
        }
        <span class="hljs-keyword">return</span> head;
    }
};
</div></code></pre>
<h3 id="61旋转链表链表">61.旋转链表(链表)</h3>
<p><a href="https://leetcode-cn.com/problems/rotate-list/">旋转链表</a></p>
<pre><code class="language-c++"><div><span class="hljs-comment">//61.旋转链表</span>
<span class="hljs-comment">//2021.3.27</span>
<span class="hljs-comment">//旋转k次 实际就是 将k mod len(指链表长度) 个元素向右移动一次</span>
<span class="hljs-comment">//形成环形链表后 在 len - (k mod len) 处切断链表即可</span>

<span class="hljs-comment">//Definition for singly-linked list.</span>
<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ListNode</span> {</span>
    <span class="hljs-keyword">int</span> val;
    ListNode *next;
    ListNode() : val(<span class="hljs-number">0</span>), next(<span class="hljs-literal">nullptr</span>) {}
    ListNode(<span class="hljs-keyword">int</span> x) : val(x), next(<span class="hljs-literal">nullptr</span>) {}
    ListNode(<span class="hljs-keyword">int</span> x, ListNode *next) : val(x), next(next) {}
};
 
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> {</span>
<span class="hljs-keyword">public</span>:
    <span class="hljs-function">ListNode* <span class="hljs-title">rotateRight</span><span class="hljs-params">(ListNode* head, <span class="hljs-keyword">int</span> k)</span> </span>{
        <span class="hljs-keyword">if</span>( k == <span class="hljs-number">0</span> || head == <span class="hljs-literal">nullptr</span> || head-&gt;next == <span class="hljs-literal">nullptr</span>)
        {
            <span class="hljs-keyword">return</span> head;
        }
        <span class="hljs-keyword">int</span> len = <span class="hljs-number">1</span>;
        ListNode* cur;
        cur = head;
        <span class="hljs-keyword">while</span>(cur-&gt;next != <span class="hljs-literal">NULL</span>)
        {
            cur = cur-&gt;next;
            len++;
        }
        <span class="hljs-comment">//形成环形链表</span>
        cur-&gt;next = head;
        cur = head;
        <span class="hljs-keyword">int</span> cnt = len - k%len;
        <span class="hljs-comment">//找到对应地方切断</span>
        <span class="hljs-keyword">while</span>(cnt &gt; <span class="hljs-number">1</span>)
        {
            cur = cur-&gt;next;
            cnt--;
        }
        head = cur-&gt;next;
        cur-&gt;next = <span class="hljs-literal">nullptr</span>;
        <span class="hljs-keyword">return</span> head;
    }
};
</div></code></pre>
<h2 id="202142">2021.4.2</h2>
<h3 id="面试题1721直方图的水量双指针">面试题17.21.直方图的水量(双指针)</h3>
<p><a href="https://leetcode-cn.com/problems/volume-of-histogram-lcci/">面试题17.21.直方图的水量</a></p>
<pre><code class="language-c++"><div><span class="hljs-comment">//面试题17.21.直方图的水量</span>
<span class="hljs-comment">//2021.4.2</span>
<span class="hljs-comment">//双指针左指针维持左边的最大值 右指针维持右边 哪个最大值小 就是其-当前遍历值</span>
<span class="hljs-comment">// 时On 空O1</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> {</span>
<span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">trap</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; height)</span> </span>{
        <span class="hljs-keyword">if</span>(height.size() &lt;=<span class="hljs-number">2</span> )<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
        <span class="hljs-keyword">int</span> ans = <span class="hljs-number">0</span>;
        <span class="hljs-keyword">int</span> left = <span class="hljs-number">0</span>;
        <span class="hljs-keyword">int</span> right = height.size() - <span class="hljs-number">1</span>;
        <span class="hljs-keyword">int</span> leftMax = height[left];
        <span class="hljs-keyword">int</span> rightMax = height[right];
        <span class="hljs-keyword">while</span>(left &lt; right)
        {
            <span class="hljs-keyword">if</span>(leftMax &lt; rightMax)
            {
                ans += (leftMax - height[left]);
                left++;
                leftMax = max(leftMax,height[left]);
            }
            <span class="hljs-keyword">else</span>
            {
                ans += (rightMax - height[right]);
                right--;
                rightMax = max(rightMax,height[right]);
            }
        }
        <span class="hljs-keyword">return</span> ans;
    }
};
</div></code></pre>
<h3 id="1006笨阶乘数学">1006.笨阶乘(数学)</h3>
<p><a href="https://leetcode-cn.com/problems/clumsy-factorial/">笨阶乘</a></p>
<pre><code class="language-c++"><div><span class="hljs-comment">//1006.笨阶乘</span>
<span class="hljs-comment">//2021.4.2</span>
<span class="hljs-comment">//观察数学规律 N对4取余 可判断最后一项运算符号</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> {</span>
<span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">clumsy</span><span class="hljs-params">(<span class="hljs-keyword">int</span> N)</span> </span>{
        <span class="hljs-keyword">if</span>(N == <span class="hljs-number">1</span>)<span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;
        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(N == <span class="hljs-number">2</span>)<span class="hljs-keyword">return</span> <span class="hljs-number">2</span>;
        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(N == <span class="hljs-number">3</span>)<span class="hljs-keyword">return</span> <span class="hljs-number">6</span>;
        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(N == <span class="hljs-number">4</span>)<span class="hljs-keyword">return</span> <span class="hljs-number">7</span>;
        <span class="hljs-keyword">if</span> (N % <span class="hljs-number">4</span> == <span class="hljs-number">0</span>) {
            <span class="hljs-keyword">return</span> N + <span class="hljs-number">1</span>;
        } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (N % <span class="hljs-number">4</span> &lt;= <span class="hljs-number">2</span>) {
            <span class="hljs-keyword">return</span> N + <span class="hljs-number">2</span>;
        } <span class="hljs-keyword">else</span> {
            <span class="hljs-keyword">return</span> N - <span class="hljs-number">1</span>;
        }
    }
};
</div></code></pre>
<h2 id="202144">2021.4.4</h2>
<h3 id="781森林中的兔子贪心">781.森林中的兔子(贪心)</h3>
<p><a href="https://leetcode-cn.com/problems/rabbits-in-forest/">森林中的兔子</a></p>
<pre><code class="language-c++"><div><span class="hljs-comment">//781.森林中的兔子</span>
<span class="hljs-comment">//2021.4.4</span>
<span class="hljs-comment">//先按升序排序 说法相同的 尽可能归为同色兔子</span>
<span class="hljs-comment">//用canAppear 判别还能不能是同色兔子</span>
<span class="hljs-comment">//贪心 将每种说法相同的计算好加起来即可</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> {</span>
<span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">numRabbits</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; answers)</span> </span>{
        <span class="hljs-keyword">if</span>(answers.size() == <span class="hljs-number">0</span>)<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
        <span class="hljs-keyword">int</span> ans = <span class="hljs-number">0</span>;
        <span class="hljs-keyword">int</span> pre = <span class="hljs-number">-1</span>;
        <span class="hljs-keyword">int</span> canAppear = <span class="hljs-number">-1</span>;
        sort(answers.begin(),answers.end());
        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i &lt; answers.size();i++)
        {
            <span class="hljs-keyword">if</span>(answers[i] != pre || canAppear &lt;= <span class="hljs-number">0</span>)
            {
                ans += (<span class="hljs-number">1</span> + answers[i]);
                pre = answers[i];
                canAppear = answers[i];
            }
            <span class="hljs-keyword">else</span>
            {
                canAppear--;
            }
        }
        <span class="hljs-keyword">return</span> ans;
    }
};
</div></code></pre>
<h2 id="202145">2021.4.5</h2>
<h3 id="88合并两个有序数组双指针">88.合并两个有序数组(双指针)</h3>
<p><a href="https://leetcode-cn.com/problems/merge-sorted-array/">合并两个有序数组</a></p>
<pre><code class="language-c++"><div><span class="hljs-comment">//88.合并两个有序数组</span>
<span class="hljs-comment">//2021.4.5</span>
<span class="hljs-comment">//双指针 构建一个中间数组 然后再赋值给nums1</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> {</span>
<span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">merge</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums1, <span class="hljs-keyword">int</span> m, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums2, <span class="hljs-keyword">int</span> n)</span> </span>{
        <span class="hljs-keyword">int</span> p1 = <span class="hljs-number">0</span>, p2 = <span class="hljs-number">0</span>;
        <span class="hljs-keyword">int</span> sorted[m + n];
        <span class="hljs-keyword">int</span> cur;
        <span class="hljs-keyword">while</span> (p1 &lt; m || p2 &lt; n) {
            <span class="hljs-keyword">if</span> (p1 == m) {
                cur = nums2[p2++];
            } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (p2 == n) {
                cur = nums1[p1++];
            } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nums1[p1] &lt; nums2[p2]) {
                cur = nums1[p1++];
            } <span class="hljs-keyword">else</span> {
                cur = nums2[p2++];
            }
            sorted[p1 + p2 - <span class="hljs-number">1</span>] = cur;
        }
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i != m + n; ++i) {
            nums1[i] = sorted[i];
        }
    }
};
</div></code></pre>
<h2 id="202146">2021.4.6</h2>
<h3 id="80删除有序数组中的重复项">80.删除有序数组中的重复项||</h3>
<p><a href="https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array-ii/">删除有序数组中的重复项||</a></p>
<pre><code class="language-c++"><div><span class="hljs-comment">//80.删除有序数组中的重复项||</span>
<span class="hljs-comment">//2021.4.6</span>
<span class="hljs-comment">//计数 第三次出现就删掉</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> {</span>
<span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">removeDuplicates</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums)</span> </span>{
        <span class="hljs-keyword">int</span> cnt = <span class="hljs-number">1</span>;
        <span class="hljs-keyword">int</span> len = nums.size();
        <span class="hljs-keyword">if</span>(len &lt;= <span class="hljs-number">2</span>)<span class="hljs-keyword">return</span> len;
        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;len;i++)
        {
            <span class="hljs-keyword">if</span>(nums[i] == nums[i<span class="hljs-number">-1</span>])
            {
                cnt++;
                <span class="hljs-comment">// 第三次出现相同数字</span>
                <span class="hljs-keyword">if</span>(cnt&gt;<span class="hljs-number">2</span>)
                {
                    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=i;j&lt;len<span class="hljs-number">-1</span>;j++)
                    {
                        nums[j] = nums[j+<span class="hljs-number">1</span>];
                    }
                    i--;
                    len--;
                }
            }
            <span class="hljs-keyword">else</span>
            {
                cnt = <span class="hljs-number">1</span>;
            }
        }
        <span class="hljs-keyword">return</span> len;
    }
};
<span class="hljs-comment">//双指针</span>
<span class="hljs-comment">// class Solution {</span>
<span class="hljs-comment">// public:</span>
<span class="hljs-comment">//     int removeDuplicates(vector&lt;int&gt;&amp; nums) {</span>
<span class="hljs-comment">//         int n = nums.size();</span>
<span class="hljs-comment">//         if (n &lt;= 2) {</span>
<span class="hljs-comment">//             return n;</span>
<span class="hljs-comment">//         }</span>
<span class="hljs-comment">//         int slow = 2, fast = 2;</span>
<span class="hljs-comment">//         while (fast &lt; n) {</span>
<span class="hljs-comment">//             if (nums[slow - 2] != nums[fast]) {</span>
<span class="hljs-comment">//                 nums[slow] = nums[fast];</span>
<span class="hljs-comment">//                 ++slow;</span>
<span class="hljs-comment">//             }</span>
<span class="hljs-comment">//             ++fast;</span>
<span class="hljs-comment">//         }</span>
<span class="hljs-comment">//         return slow;</span>
<span class="hljs-comment">//     }</span>
<span class="hljs-comment">// };</span>
</div></code></pre>
<h2 id="202147">2021.4.7</h2>
<h3 id="81搜索旋转排序数组">81.搜索旋转排序数组||</h3>
<p><a href="https://leetcode-cn.com/problems/search-in-rotated-sorted-array-ii/submissions/">搜索旋转排序数组||</a></p>
<pre><code class="language-c++"><div><span class="hljs-comment">//81.搜索旋转排序数组||</span>
<span class="hljs-comment">//2021.4.7</span>
<span class="hljs-comment">//二分法</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> {</span>
<span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">search</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums, <span class="hljs-keyword">int</span> target)</span> </span>{
        <span class="hljs-keyword">int</span> len = nums.size();
        <span class="hljs-keyword">if</span>(len == <span class="hljs-number">1</span>)<span class="hljs-keyword">return</span> nums[<span class="hljs-number">0</span>] == target;
        <span class="hljs-keyword">int</span> left = <span class="hljs-number">0</span>, right = len - <span class="hljs-number">1</span>;
        <span class="hljs-keyword">int</span> middle = (left + right)/<span class="hljs-number">2</span>;
        <span class="hljs-keyword">while</span>(left &lt;= right)
        {
            middle = (left + right)/<span class="hljs-number">2</span>;
            <span class="hljs-keyword">if</span>(nums[middle] == target)<span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
            <span class="hljs-keyword">if</span>(nums[middle] == nums[left] &amp;&amp; nums[middle] == nums[right])
            {
                left++;
                right--;
            }
            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(nums[left] &lt;= nums[middle])
            {
                <span class="hljs-keyword">if</span>(nums[middle] &gt; target &amp;&amp; target &gt;= nums[left])
                {
                    right = middle - <span class="hljs-number">1</span>;
                }
                <span class="hljs-keyword">else</span>
                {
                    left = middle + <span class="hljs-number">1</span>;
                }
            }
            <span class="hljs-keyword">else</span>
            {
                <span class="hljs-keyword">if</span>(nums[middle] &lt; target &amp;&amp; target &lt;= nums[len<span class="hljs-number">-1</span>])
                {
                    left = middle + <span class="hljs-number">1</span>; 
                }
                <span class="hljs-keyword">else</span>
                {
                    right = middle - <span class="hljs-number">1</span>;
                }
            }
        }
        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
    }
};
</div></code></pre>
<h2 id="2021411">2021.4.11</h2>
<h3 id="264丑数动态规划">264.丑数||(动态规划)</h3>
<p><a href="https://leetcode-cn.com/problems/ugly-number-ii/">丑数||</a></p>
<pre><code class="language-c++"><div><span class="hljs-comment">//264.丑数||</span>
<span class="hljs-comment">//2021.4.11</span>
<span class="hljs-comment">//动态规划 后面的丑数由前面的丑数 *2 *3 或*5得到</span>
<span class="hljs-comment">//三个指针</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> {</span>
<span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">nthUglyNumber</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>{
       <span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">col</span><span class="hljs-params">(n+<span class="hljs-number">1</span>)</span></span>;
       col[<span class="hljs-number">1</span>] = <span class="hljs-number">1</span>;
       <span class="hljs-keyword">int</span> p2 = <span class="hljs-number">1</span>, p3  = <span class="hljs-number">1</span>, p5 = <span class="hljs-number">1</span>;
       <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">2</span>;i &lt;= n;i++)
       {
           <span class="hljs-keyword">int</span> num2 = col[p2] * <span class="hljs-number">2</span>;
           <span class="hljs-keyword">int</span> num3 = col[p3] * <span class="hljs-number">3</span>;
           <span class="hljs-keyword">int</span> num5 = col[p5] * <span class="hljs-number">5</span>;
           col[i] = min(min(num2,num3), num5);
           <span class="hljs-keyword">if</span>(col[i] == num2)p2++;
           <span class="hljs-keyword">if</span>(col[i] == num3)p3++;
           <span class="hljs-keyword">if</span>(col[i] == num5)p5++;
       }
       <span class="hljs-keyword">return</span> col[n];
    }
};
</div></code></pre>
<h2 id="202179">2021.7.9</h2>
<h3 id="5最长回文子串动态规划">5.最长回文子串(动态规划)</h3>
<p><a href="https://leetcode-cn.com/problems/longest-palindromic-substring/">最长回文子串</a></p>
<pre><code class="language-c++"><div><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> {</span>
<span class="hljs-keyword">public</span>:
<span class="hljs-comment">//1.动态规划</span>
<span class="hljs-comment">//s[i][j]=s[i+1][j-1] &amp; s[i]==s[j]</span>
<span class="hljs-comment">//时间复杂度On2 空间复杂度On2</span>
    <span class="hljs-comment">// string longestPalindrome1(string s) {</span>
    <span class="hljs-comment">//     int len = s.size();</span>
    <span class="hljs-comment">//     if(len &lt;= 1)return s;</span>
    <span class="hljs-comment">//     int beginIndex = 0;</span>
    <span class="hljs-comment">//     int maxLength = 1;</span>
    <span class="hljs-comment">//     vector&lt;vector&lt;int&gt;&gt; dp(len, vector&lt;int&gt;(len));</span>
    <span class="hljs-comment">//     for(int i = 0;i &lt; len;i++)</span>
    <span class="hljs-comment">//     {</span>
    <span class="hljs-comment">//         dp[i][i] = true;</span>
    <span class="hljs-comment">//     }</span>
    <span class="hljs-comment">//     for (int L = 2;L &lt;= len;L++)</span>
    <span class="hljs-comment">//     {</span>
    <span class="hljs-comment">//         for(int i = 0;i &lt; len;i++)</span>
    <span class="hljs-comment">//         {</span>
    <span class="hljs-comment">//             int j = i + L - 1;</span>
    <span class="hljs-comment">//             //越界返回</span>
    <span class="hljs-comment">//             if(j &gt;= len)break;</span>
    <span class="hljs-comment">//             if(s[i] == s[j])</span>
    <span class="hljs-comment">//             {</span>
    <span class="hljs-comment">//                 if((j - i + 1) &lt; 3)</span>
    <span class="hljs-comment">//                 {</span>
    <span class="hljs-comment">//                     dp[i][j] = true;</span>
    <span class="hljs-comment">//                 }</span>
    <span class="hljs-comment">//                 else</span>
    <span class="hljs-comment">//                 {</span>
    <span class="hljs-comment">//                     dp[i][j] = dp[i+1][j-1];</span>
    <span class="hljs-comment">//                 }</span>
    <span class="hljs-comment">//             }</span>
    <span class="hljs-comment">//             else</span>
    <span class="hljs-comment">//             {</span>
    <span class="hljs-comment">//                 dp[i][j] = false;</span>
    <span class="hljs-comment">//             }</span>
    <span class="hljs-comment">//             if(dp[i][j] == true &amp;&amp; (j - i + 1) &gt; maxLength)</span>
    <span class="hljs-comment">//             {</span>
    <span class="hljs-comment">//                 maxLength = (j - i + 1);</span>
    <span class="hljs-comment">//                 beginIndex = i;</span>
    <span class="hljs-comment">//             }</span>
    <span class="hljs-comment">//         }</span>
    <span class="hljs-comment">//     }</span>
    <span class="hljs-comment">//     return s.substr(begin,maxLength);</span>
    <span class="hljs-comment">// }</span>

    <span class="hljs-comment">//2.中心扩散算法</span>
    <span class="hljs-function"><span class="hljs-built_in">pair</span>&lt;<span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>&gt; <span class="hljs-title">fun</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-built_in">string</span>&amp; s,<span class="hljs-keyword">int</span> left, <span class="hljs-keyword">int</span> right)</span>
    </span>{
        <span class="hljs-keyword">while</span>(left&gt;=<span class="hljs-number">0</span> &amp;&amp; right&lt;s.size() &amp;&amp; s[left] == s[right])
        {
            left--;
            right++;
        }
        <span class="hljs-keyword">return</span> {left+<span class="hljs-number">1</span>, right<span class="hljs-number">-1</span>};
    }
    <span class="hljs-function"><span class="hljs-built_in">string</span> <span class="hljs-title">longestPalindrome2</span><span class="hljs-params">(<span class="hljs-built_in">string</span> s)</span> </span>{
        <span class="hljs-keyword">int</span> len = s.size();
        <span class="hljs-keyword">if</span>(len &lt;= <span class="hljs-number">1</span>)<span class="hljs-keyword">return</span> s;
        <span class="hljs-keyword">int</span> start = <span class="hljs-number">0</span>;
        <span class="hljs-keyword">int</span> end = <span class="hljs-number">0</span>;
        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;len;i++)
        {
            <span class="hljs-keyword">auto</span>[left1, right1] = fun(s, i, i); <span class="hljs-comment">//单个字符的中心点</span>
            <span class="hljs-keyword">auto</span>[left2, right2] = fun(s, i, i+<span class="hljs-number">1</span>);<span class="hljs-comment">//两个字符的中心点 若两个字符不同 则会返回1</span>
            <span class="hljs-keyword">if</span>((right1 - left1)&gt;(end - start))
            {
                start = left1;
                end = right1;
            }
            <span class="hljs-keyword">if</span>((right2 - left2)&gt;(end - start))
            {
                start = left2;
                end = right2;
            }
        }
        <span class="hljs-keyword">return</span> s.substr(start,end - start + <span class="hljs-number">1</span>);
        
    }
};
</div></code></pre>
<h3 id="1710-主要元素mapboyer-moore-投票算法">17.10 主要元素(map、Boyer-Moore 投票算法)</h3>
<p><a href="https://leetcode-cn.com/problems/find-majority-element-lcci/">主要元素</a></p>
<pre><code class="language-c++"><div><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> {</span>
<span class="hljs-comment">//1. map存储每个元素出现的次数</span>
<span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">majorityElement1</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums)</span> </span>{
        <span class="hljs-keyword">if</span> (nums.size() &lt;= <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> nums[<span class="hljs-number">0</span>];
        <span class="hljs-built_in">map</span> &lt;<span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>&gt; mymap;
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.size(); i++)
        {
            <span class="hljs-built_in">map</span>&lt;<span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>&gt;::iterator iter = mymap.find(nums[i]);
            <span class="hljs-comment">// map中已有该元素</span>
            <span class="hljs-keyword">if</span> (iter != mymap.end())
            {
                <span class="hljs-keyword">if</span>(++(iter-&gt;second) &gt; nums.size() / <span class="hljs-number">2</span>)<span class="hljs-keyword">return</span> iter-&gt;first;
            }
            <span class="hljs-keyword">else</span>
            {
                <span class="hljs-comment">// 插入该元素</span>
                mymap.insert(<span class="hljs-built_in">pair</span>&lt;<span class="hljs-keyword">int</span>,<span class="hljs-keyword">int</span>&gt;(nums[i], <span class="hljs-number">1</span>));
            }
        }
        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;
    }
    <span class="hljs-comment">//2.Boyer-Moore 投票算法</span>
    <span class="hljs-comment">//维护一个候选者元素 遇到相同count++ 不同-- count=0时替换新候选者 若为主要元素 与不同元素抵消后一定还剩一个以上</span>
    <span class="hljs-comment">//时间复杂度On 空间复杂度O1</span>
    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">majorityElement2</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums)</span> </span>{
        <span class="hljs-keyword">if</span> (nums.size() &lt;= <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> nums[<span class="hljs-number">0</span>];
        <span class="hljs-keyword">int</span> candidate = <span class="hljs-number">0</span>, count = <span class="hljs-number">0</span>;<span class="hljs-comment">//候选者和其出现次数</span>
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.size(); i++)
        {
            <span class="hljs-keyword">if</span>(count == <span class="hljs-number">0</span>)
            {
                candidate = nums[i];
                count++;
            }
            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(candidate == nums[i])
            {
                count++;
            }
            <span class="hljs-keyword">else</span>
            {
                count--;
            }
        }
        count = <span class="hljs-number">0</span>;
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.size(); i++)
        {
            <span class="hljs-keyword">if</span>(candidate == nums[i])
            {
                count++;
            }
        }
        <span class="hljs-keyword">if</span>(count &gt; nums.size()/<span class="hljs-number">2</span>)
        {
            <span class="hljs-keyword">return</span> candidate;
        }
        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;
    }
};
</div></code></pre>
<h2 id="2021710">2021.7.10</h2>
<h3 id="21合并两个有序链表迭代法">21.合并两个有序链表(迭代法)</h3>
<p><a href="https://leetcode-cn.com/problems/merge-two-sorted-lists/">合并两个有序链表</a></p>
<pre><code class="language-c++"><div><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> {</span>
<span class="hljs-keyword">public</span>:
<span class="hljs-comment">//迭代法</span>
    <span class="hljs-function">ListNode* <span class="hljs-title">mergeTwoLists</span><span class="hljs-params">(ListNode* l1, ListNode* l2)</span> </span>{
        ListNode* ans = <span class="hljs-keyword">new</span> ListNode(<span class="hljs-number">-1</span>);
        ListNode* temp = ans;
        <span class="hljs-keyword">while</span>(l1 != <span class="hljs-literal">nullptr</span> || l2 != <span class="hljs-literal">nullptr</span>)
        {
            <span class="hljs-keyword">if</span>(l1 != <span class="hljs-literal">nullptr</span> &amp;&amp; l2 != <span class="hljs-literal">nullptr</span>)
            {
                <span class="hljs-keyword">if</span>(l1-&gt;val &lt;= l2-&gt;val)
                {
                    temp -&gt; next = l1;
                    l1 = l1 -&gt; next;
                }
                <span class="hljs-keyword">else</span>
                {
                    temp -&gt; next = l2;
                    l2 = l2 -&gt; next;
                }
            }
            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(l1 != <span class="hljs-literal">nullptr</span>)
            {
                temp -&gt; next = l1;
                l1 = l1 -&gt; next;
            }
            <span class="hljs-keyword">else</span>
            {
                temp -&gt; next = l2;
                l2 = l2 -&gt; next;
            }
            temp = temp -&gt; next;
        }
        <span class="hljs-keyword">return</span> ans -&gt; next;
    }
    
};
</div></code></pre>
<h3 id="22括号生成回溯法">22.括号生成(回溯法)</h3>
<p><a href="https://leetcode-cn.com/problems/generate-parentheses/">括号生成</a></p>
<pre><code class="language-c++"><div><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> {</span>
<span class="hljs-keyword">public</span>:
<span class="hljs-comment">//回溯法</span>
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">back2</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">string</span>&gt;&amp; result, <span class="hljs-built_in">string</span>&amp; cur, <span class="hljs-keyword">int</span> open,<span class="hljs-keyword">int</span> close,<span class="hljs-keyword">int</span> n)</span>
    </span>{
        <span class="hljs-comment">//完成一种组合</span>
        <span class="hljs-keyword">if</span>(cur.size() == (n*<span class="hljs-number">2</span>))
        {
            result.push_back(cur);
            <span class="hljs-keyword">return</span>;
        }
        <span class="hljs-comment">//左括号数小于n</span>
        <span class="hljs-keyword">if</span>(open &lt; n)
        {
            cur.push_back(<span class="hljs-string">&#x27;(&#x27;</span>);
            back2(result, cur, open + <span class="hljs-number">1</span>, close, n);
            <span class="hljs-comment">//回溯</span>
            cur.pop_back();
        }
        <span class="hljs-comment">//左括号数大于右括号数</span>
        <span class="hljs-keyword">if</span>(open &gt; close)
        {
            cur.push_back(<span class="hljs-string">&#x27;)&#x27;</span>);
            back2(result, cur, open, close + <span class="hljs-number">1</span>, n);
            cur.pop_back();
        }
    }

    <span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">string</span>&gt; <span class="hljs-title">generateParenthesis</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>{
        <span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">string</span>&gt; result;
        <span class="hljs-built_in">string</span> cur;
        back2(result, cur, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, n);
        <span class="hljs-keyword">return</span> result;
    }
};
</div></code></pre>
<h2 id="2021712">2021.7.12</h2>
<h3 id="275h指数ⅱ2分法">275.H指数Ⅱ(2分法)</h3>
<p><a href="https://leetcode-cn.com/problems/h-index-ii/">H指数Ⅱ</a></p>
<pre><code class="language-c++"><div><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> {</span>
<span class="hljs-keyword">public</span>:
<span class="hljs-comment">//2分法</span>
    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">hIndex</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; citations)</span> </span>{
        <span class="hljs-keyword">int</span> h = <span class="hljs-number">0</span>;
        <span class="hljs-keyword">int</span> len = citations.size();
        <span class="hljs-keyword">int</span> left = <span class="hljs-number">0</span>, right = len - <span class="hljs-number">1</span>;
        <span class="hljs-keyword">int</span> mid = <span class="hljs-number">0</span>;
        <span class="hljs-keyword">while</span>(left &lt;= right)
        {
            mid = left + (right - left)/<span class="hljs-number">2</span>;
            <span class="hljs-keyword">if</span>(citations[mid] &gt;= (len - mid))
            {
                right = mid - <span class="hljs-number">1</span>;
            }
            <span class="hljs-keyword">else</span>
            {
                left = mid + <span class="hljs-number">1</span>;
            }
        } 
        <span class="hljs-keyword">return</span> citations[mid];
    }
};
</div></code></pre>
<h2 id="202182">2021.8.2</h2>
<h3 id="94二叉树的中序遍历递归morris">94.二叉树的中序遍历(递归、Morris)</h3>
<p><a href="">二叉树的中序遍历</a></p>
<pre><code class="language-c++"><div><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">TreeNode</span> {</span>
    <span class="hljs-keyword">int</span> val;
    TreeNode *left;
    TreeNode *right;
    TreeNode() : val(<span class="hljs-number">0</span>), left(<span class="hljs-literal">nullptr</span>), right(<span class="hljs-literal">nullptr</span>) {}
    TreeNode(<span class="hljs-keyword">int</span> x) : val(x), left(<span class="hljs-literal">nullptr</span>), right(<span class="hljs-literal">nullptr</span>) {}
    TreeNode(<span class="hljs-keyword">int</span> x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
};
<span class="hljs-comment">//1.递归 时On 空On</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> {</span>
<span class="hljs-keyword">public</span>:
    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; ans;
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">midBianLi</span><span class="hljs-params">(TreeNode* node)</span>
    </span>{
        <span class="hljs-keyword">if</span>(node)
        {
            <span class="hljs-keyword">if</span>(node-&gt;left)
            {
                midBianLi(node-&gt;left);
            }
            ans.push_back(node-&gt;val);
            <span class="hljs-keyword">if</span>(node-&gt;right)
            {
                midBianLi(node-&gt;right);
            }
        }
        <span class="hljs-keyword">return</span>;
    }
    <span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">inorderTraversal</span><span class="hljs-params">(TreeNode* root)</span> </span>{
        midBianLi(root);
        <span class="hljs-keyword">return</span> ans;
    }
<span class="hljs-comment">//2.Morris 中序遍历 时间On 空间O1</span>
    <span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">MorrisinorderTraversal</span><span class="hljs-params">(TreeNode* root)</span> </span>{
        <span class="hljs-keyword">while</span>(root != <span class="hljs-literal">nullptr</span>)
        {
            <span class="hljs-comment">//有左子树</span>
            <span class="hljs-keyword">if</span>(root-&gt;left)
            {
                TreeNode* predecessor = root-&gt;left;
                <span class="hljs-comment">//找到最右节点 若检查到最右节点已将其右子树指向当前节点就退出循环</span>
                <span class="hljs-keyword">while</span>(predecessor-&gt;right != <span class="hljs-literal">nullptr</span> &amp;&amp; predecessor-&gt;right != root)
                {
                    predecessor = predecessor-&gt;right;
                }
                <span class="hljs-comment">//未赋值则赋值</span>
                <span class="hljs-keyword">if</span>(predecessor-&gt;right == <span class="hljs-literal">nullptr</span>)
                {
                    predecessor-&gt;right = root;
                    root = root-&gt;left;
                }
                <span class="hljs-comment">//已赋值表示该左子树已全部遍历 将当前值插入再遍历右子树即可</span>
                <span class="hljs-keyword">else</span>
                {
                    ans.push_back(root-&gt;val);
                    <span class="hljs-comment">//用完注意需要将predecessor-&gt;right重置 不然就有回路就不是树了</span>
                    predecessor-&gt;right = <span class="hljs-literal">nullptr</span>;
                    root = root-&gt;right;
                }
            }
            <span class="hljs-comment">//无左子树 则直接该值插入 再遍历右子树</span>
            <span class="hljs-comment">//注意！！！ 此处的右子树有两种情况</span>
            <span class="hljs-comment">//1.真右子树</span>
            <span class="hljs-comment">//2.走回之前的节点</span>
            <span class="hljs-keyword">else</span>
            {
                ans.push_back(root-&gt;val);
                root = root-&gt;right;
            }
            <span class="hljs-keyword">return</span> ans;
        }
    }
};
</div></code></pre>
<h3 id="95不同的二叉搜索树ⅱ回溯">95.不同的二叉搜索树Ⅱ(回溯)</h3>
<p><a href="">不同的二叉搜索树Ⅱ</a></p>
<pre><code class="language-c++"><div>    <span class="hljs-comment">//回溯</span>
    <span class="hljs-comment">//emplace_back() 和 push_back() 的区别，就在于底层实现的机制不同。</span>
    <span class="hljs-comment">//push_back() 向容器尾部添加元素时，首先会创建这个元素，然后再将这个元素拷贝或者移动到容器中（如果是拷贝的话，事后会自行销毁先前创建的这个元素）；</span>
    <span class="hljs-comment">//而 emplace_back() 在实现时，则是直接在容器尾部创建这个元素，省去了拷贝或移动元素的过程。</span>
    <span class="hljs-comment">//Definition for a binary tree node.</span>
    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">TreeNode</span> {</span>
        <span class="hljs-keyword">int</span> val;
        TreeNode *left;
        TreeNode *right;
        TreeNode() : val(<span class="hljs-number">0</span>), left(<span class="hljs-literal">nullptr</span>), right(<span class="hljs-literal">nullptr</span>) {}
        TreeNode(<span class="hljs-keyword">int</span> x) : val(x), left(<span class="hljs-literal">nullptr</span>), right(<span class="hljs-literal">nullptr</span>) {}
        TreeNode(<span class="hljs-keyword">int</span> x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
    };

    <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> {</span>
    <span class="hljs-keyword">public</span>:
        
        <span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;TreeNode*&gt; <span class="hljs-title">build</span><span class="hljs-params">(<span class="hljs-keyword">int</span> start,<span class="hljs-keyword">int</span> end)</span>
        </span>{
            <span class="hljs-keyword">if</span>(start&gt;end)<span class="hljs-keyword">return</span> {<span class="hljs-literal">nullptr</span>};
            <span class="hljs-built_in">vector</span>&lt;TreeNode*&gt; allTrees;
            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=start;i&lt;=end;i++)
            {
                <span class="hljs-comment">//左子树集合</span>
                <span class="hljs-built_in">vector</span>&lt;TreeNode*&gt; leftTrees = build(start,i<span class="hljs-number">-1</span>);
                <span class="hljs-comment">//右子树集合</span>
                <span class="hljs-built_in">vector</span>&lt;TreeNode*&gt; rightTrees = build(i+<span class="hljs-number">1</span>,end);
                <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span>&amp; left:leftTrees)
                {
                    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span>&amp; right:rightTrees)
                    {
                        TreeNode* curTreeNode = <span class="hljs-keyword">new</span> TreeNode(i,left,right);
                        allTrees.emplace_back(curTreeNode);
                    }
                }
            }
            <span class="hljs-keyword">return</span> allTrees;
        }
        <span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;TreeNode*&gt; <span class="hljs-title">generateTrees</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>{
            <span class="hljs-built_in">vector</span>&lt;TreeNode*&gt; ans = build(<span class="hljs-number">1</span>,n);
            <span class="hljs-keyword">return</span> ans;
        }
    };
</div></code></pre>
<h3 id="104二叉树的最大深度dfs">104.二叉树的最大深度(dfs)</h3>
<p><a href="">二叉树的最大深度</a></p>
<pre><code class="language-c++"><div>    <span class="hljs-comment">//104.二叉树的最大深度</span>
    <span class="hljs-comment">//2021.7.30</span>
    <span class="hljs-comment">//递归 深度优先遍历</span>
    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">TreeNode</span> {</span>
        <span class="hljs-keyword">int</span> val;
        TreeNode *left;
        TreeNode *right;
        TreeNode() : val(<span class="hljs-number">0</span>), left(<span class="hljs-literal">nullptr</span>), right(<span class="hljs-literal">nullptr</span>) {}
        TreeNode(<span class="hljs-keyword">int</span> x) : val(x), left(<span class="hljs-literal">nullptr</span>), right(<span class="hljs-literal">nullptr</span>) {}
        TreeNode(<span class="hljs-keyword">int</span> x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
    };
    
    <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> {</span>
    <span class="hljs-keyword">public</span>:
        <span class="hljs-keyword">int</span> maxDep = <span class="hljs-number">0</span>;
        <span class="hljs-keyword">int</span> cnt = <span class="hljs-number">0</span>;
        <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(TreeNode* node)</span>
        </span>{
            <span class="hljs-keyword">if</span>(node)
            {
                cnt++;
                <span class="hljs-keyword">if</span>((!node-&gt;left) &amp;&amp; (!node-&gt;right))
                {
                    <span class="hljs-keyword">if</span>(cnt&gt;maxDep)
                    {
                        maxDep = cnt;
                    }
                <span class="hljs-keyword">return</span>;
                }
                <span class="hljs-keyword">if</span>(node-&gt;left)
                {
                    dfs(node-&gt;left);
                    cnt--;
                }
                <span class="hljs-keyword">if</span>(node-&gt;right)
                {
                    dfs(node-&gt;right);
                    cnt--;
                }
            }
        }
        <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">maxDepth</span><span class="hljs-params">(TreeNode* root)</span> </span>{
            <span class="hljs-comment">// write code here</span>
            dfs(root);
            <span class="hljs-keyword">return</span> maxDep;
        }
    };
</div></code></pre>
<h3 id="671二叉树中第二小的节点dfs">671.二叉树中第二小的节点(dfs)</h3>
<p><a href="">二叉树中第二小的节点</a></p>
<pre><code class="language-c++"><div><span class="hljs-comment">//dfs深度优先遍历</span>
<span class="hljs-comment">//Definition for a binary tree node.</span>
<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">TreeNode</span> {</span>
     <span class="hljs-keyword">int</span> data;
     TreeNode *left;
      TreeNode *right;
      TreeNode() : data(<span class="hljs-number">0</span>), left(<span class="hljs-literal">nullptr</span>), right(<span class="hljs-literal">nullptr</span>) {}
      TreeNode(<span class="hljs-keyword">int</span> x) : data(x), left(<span class="hljs-literal">nullptr</span>), right(<span class="hljs-literal">nullptr</span>) {}
      TreeNode(<span class="hljs-keyword">int</span> x, TreeNode *left, TreeNode *right) : data(x), left(left), right(right) {}
  };

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> {</span>
<span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">findSecondMinimumValue</span><span class="hljs-params">(TreeNode* root)</span> </span>{
        <span class="hljs-keyword">int</span> ans = <span class="hljs-number">-1</span>;
        <span class="hljs-keyword">int</span> rootValue = root-&gt;data;
        function&lt;<span class="hljs-keyword">void</span>(TreeNode*)&gt; dfs = [&amp;](TreeNode* node)
        {
            <span class="hljs-keyword">if</span>(!node)
            {
                <span class="hljs-keyword">return</span>;
            }
            <span class="hljs-keyword">if</span>(ans != <span class="hljs-number">-1</span> &amp;&amp; node-&gt;data &gt;= ans)
            {
                <span class="hljs-keyword">return</span>;
            }
            <span class="hljs-keyword">if</span>(node-&gt;data &gt; rootValue)
            {
                ans = node-&gt;data;
            }
            dfs(node-&gt;left);
            dfs(node-&gt;right);
        };
        dfs(root);
        <span class="hljs-keyword">return</span> ans;
    }
};
</div></code></pre>
<h3 id="1337矩阵中战斗力最弱的k行纵向遍历">1337.矩阵中战斗力最弱的K行(纵向遍历)</h3>
<p><a href="">矩阵中战斗力最弱的K行</a></p>
<pre><code class="language-c++"><div><span class="hljs-comment">//纵向遍历 时Omn</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> {</span>
<span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">kWeakestRows</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&gt;&amp; mat, <span class="hljs-keyword">int</span> k)</span> </span>{
        <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; ans;
        <span class="hljs-keyword">int</span> row = mat.size();
        <span class="hljs-keyword">if</span>(row == <span class="hljs-number">0</span>)<span class="hljs-keyword">return</span> ans;
        <span class="hljs-keyword">int</span> col = mat[<span class="hljs-number">0</span>].size();
        
        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i &lt; col;i++)
        {
            <span class="hljs-keyword">if</span>(k&lt;=<span class="hljs-number">0</span>)<span class="hljs-keyword">break</span>;
            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>;j &lt; row;j++)
            {
                <span class="hljs-keyword">if</span>(k&lt;=<span class="hljs-number">0</span>)<span class="hljs-keyword">break</span>;
                <span class="hljs-comment">//将对应行数推入数组</span>
                <span class="hljs-keyword">auto</span> it = find(ans.cbegin(),ans.cend(),j);
                <span class="hljs-keyword">if</span>(mat[j][i] == <span class="hljs-number">0</span> &amp;&amp; it == ans.cend())
                {
                    ans.push_back(j);
                    k--;
                }
            }
        }
        <span class="hljs-comment">//全部都是1也要算入的情况</span>
        <span class="hljs-keyword">if</span>(k&gt;<span class="hljs-number">0</span>)
        {
            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;row;i++)
            {
                <span class="hljs-keyword">if</span>(k&lt;=<span class="hljs-number">0</span>)<span class="hljs-keyword">break</span>;
                <span class="hljs-keyword">if</span>(mat[i][col<span class="hljs-number">-1</span>] == <span class="hljs-number">1</span>)
                {
                    ans.push_back(i);
                    k--;
                }
            }
        }
        <span class="hljs-keyword">return</span> ans;
        
    }
};
</div></code></pre>
<h2 id="202186">2021.8.6</h2>
<h3 id="27移除元素">27.移除元素</h3>
<p><a href="">移除元素</a></p>
<pre><code class="language-c++"><div><span class="hljs-comment">//27.移除元素</span>
<span class="hljs-comment">//2021.8.6</span>
<span class="hljs-comment">//原地算法</span>

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> {</span>
<span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">removeElement</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums, <span class="hljs-keyword">int</span> val)</span> </span>{
        <span class="hljs-keyword">int</span> index = <span class="hljs-number">0</span>;
        <span class="hljs-keyword">int</span> n = nums.size();
        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)
        {
            <span class="hljs-keyword">if</span>(nums[i]!=val)
            {
                nums[index++] = nums[i];
            }
        }
        <span class="hljs-keyword">return</span> index;
    }
};
</div></code></pre>
<h3 id="31下一个序列">31.下一个序列</h3>
<p><a href="">下一个序列</a></p>
<pre><code class="language-c++"><div><span class="hljs-comment">//1,3,2 下一个字典序为 2,1,3</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> {</span>
<span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">nextPermutation</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums)</span> </span>{
        <span class="hljs-keyword">int</span> n = nums.size();
        <span class="hljs-keyword">int</span> flag = <span class="hljs-number">0</span>;
        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i =n<span class="hljs-number">-2</span>;i&gt;=<span class="hljs-number">0</span>;i--)
        {   
            <span class="hljs-comment">//从右往左找非递减序列</span>
            <span class="hljs-keyword">if</span>(nums[i]&lt;nums[i+<span class="hljs-number">1</span>])
            {
                <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=n<span class="hljs-number">-1</span>;j&gt;i;j--)
                {
                    <span class="hljs-comment">//找最小的较大值</span>
                    <span class="hljs-keyword">if</span>(nums[j]&gt;nums[i])
                    {
                        <span class="hljs-comment">//交换即可</span>
                        flag = <span class="hljs-number">1</span>;
                        <span class="hljs-keyword">int</span> temp = nums[i];
                        nums[i] = nums[j];
                        nums[j] = temp;
                        <span class="hljs-keyword">break</span>;
                    }
                }
                sort(nums.begin()+i+<span class="hljs-number">1</span>,nums.end());
                <span class="hljs-keyword">break</span>;
            }
        }
        <span class="hljs-keyword">if</span>(flag == <span class="hljs-number">0</span>)
        {
            sort(nums.begin(),nums.end());
        }
        <span class="hljs-keyword">return</span>;
    }
};
</div></code></pre>
<h3 id="847访问所有节点的最短路径">847.访问所有节点的最短路径</h3>
<p><a href="">访问所有节点的最短路径</a></p>
<pre><code class="language-c++"><div><span class="hljs-comment">//状态压缩+广度优先搜索</span>
<span class="hljs-comment">//时On2*2n 空n*2n</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> {</span>
<span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">shortestPathLength</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&gt;&amp; graph)</span> </span>{
        <span class="hljs-keyword">int</span> n = graph.size();
        <span class="hljs-built_in">queue</span>&lt;tuple&lt;<span class="hljs-keyword">int</span>,<span class="hljs-keyword">int</span>,<span class="hljs-keyword">int</span>&gt;&gt; myQueue;
        <span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&gt; <span class="hljs-title">hasSeen</span><span class="hljs-params">(n, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;(<span class="hljs-number">1</span>&lt;&lt;n))</span></span>;
        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)
        {
            myQueue.emplace(i,<span class="hljs-number">1</span>&lt;&lt;i,<span class="hljs-number">0</span>);
            hasSeen[i][<span class="hljs-number">1</span>&lt;&lt;i] = <span class="hljs-literal">true</span>;
        }
        <span class="hljs-keyword">int</span> ans = <span class="hljs-number">0</span>;
        <span class="hljs-keyword">while</span>(!myQueue.empty())
        {
            <span class="hljs-keyword">auto</span> [index, flag, dis] = myQueue.front();
            myQueue.pop();
            <span class="hljs-keyword">if</span>(flag == (<span class="hljs-number">1</span>&lt;&lt;n) - <span class="hljs-number">1</span>)
            {
                ans = dis;
                <span class="hljs-keyword">break</span>;
            }
            <span class="hljs-comment">//搜索连通节点</span>
            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> v:graph[index])
            {
                <span class="hljs-comment">//位或 |</span>
                <span class="hljs-keyword">int</span> newFlag = flag | (<span class="hljs-number">1</span>&lt;&lt;v);
                <span class="hljs-keyword">if</span>(!hasSeen[v][newFlag])
                {
                    myQueue.emplace(v,newFlag,dis+<span class="hljs-number">1</span>);
                    hasSeen[v][newFlag] = <span class="hljs-literal">true</span>;
                }
            }
        }
        <span class="hljs-keyword">return</span> ans;
    }
};
</div></code></pre>
<h2 id="810">8.10</h2>
<h3 id="413等差数列划分">413.等差数列划分</h3>
<p><a href="">等差数列划分</a></p>
<pre><code class="language-c++"><div><span class="hljs-comment">//动态规划</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> {</span>
<span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">numberOfArithmeticSlices</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums)</span> </span>{
        <span class="hljs-keyword">int</span> ans = <span class="hljs-number">0</span>,len = <span class="hljs-number">0</span>;
        <span class="hljs-keyword">if</span>(nums.size()&lt;<span class="hljs-number">3</span>)<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">2</span>;i&lt;nums.size();i++)
        {
            <span class="hljs-comment">//三个数差相同 不同则len=0</span>
            (nums[i] - nums[i<span class="hljs-number">-1</span>]) == (nums[i<span class="hljs-number">-1</span>] - nums[i<span class="hljs-number">-2</span>])?ans+=++len:len = <span class="hljs-number">0</span>;
        }
        <span class="hljs-keyword">return</span> ans;
    }
};
</div></code></pre>
<h2 id="812">8.12</h2>
<h3 id="53最大子序和">53.最大子序和</h3>
<p><a href="">最大子序和</a></p>
<pre><code class="language-c++"><div><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> {</span>
<span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">maxSubArray</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums)</span> </span>{
        <span class="hljs-keyword">int</span> curMax = <span class="hljs-number">-100000</span>,ans = <span class="hljs-number">-100000</span>;
        <span class="hljs-keyword">if</span>(nums.size()==<span class="hljs-number">1</span>)<span class="hljs-keyword">return</span> nums[<span class="hljs-number">0</span>];
        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;nums.size();i++)
        {
            curMax = nums[i]&gt;(curMax+nums[i])?nums[i]:curMax+nums[i];
            ans = max(ans,curMax);
        }
        <span class="hljs-keyword">return</span> ans;
    }
};
</div></code></pre>
<h3 id="516最长回文子序列">516.最长回文子序列</h3>
<p>[最长回文子序列]</p>
<pre><code class="language-c++"><div><span class="hljs-comment">//动态规划 s[i]==s[j] dp[i][j]=dp[i+1][j-1]+2</span>
<span class="hljs-comment">//s[i]!=s[j] dp[i][j]=max(dp[i+1][j],dp[i][j-1])</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> {</span>
<span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">longestPalindromeSubseq</span><span class="hljs-params">(<span class="hljs-built_in">string</span> s)</span> </span>{
        <span class="hljs-keyword">int</span> len = s.size();
        <span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&gt; <span class="hljs-title">dp</span><span class="hljs-params">(len,<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;(len))</span></span>;
        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=len - <span class="hljs-number">1</span>;i&gt;=<span class="hljs-number">0</span>;i--)
        {
            dp[i][i] = <span class="hljs-number">1</span>;
            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=i + <span class="hljs-number">1</span>;j &lt; len;j++)
            {
                <span class="hljs-keyword">if</span>(s.at(i) == s.at(j))
                {
                    dp[i][j] = dp[i+<span class="hljs-number">1</span>][j<span class="hljs-number">-1</span>] + <span class="hljs-number">2</span>;
                }
                <span class="hljs-keyword">else</span>
                {
                    dp[i][j] = max(dp[i+<span class="hljs-number">1</span>][j], dp[i][j<span class="hljs-number">-1</span>]);
                }
            }
        }
        <span class="hljs-keyword">return</span> dp[<span class="hljs-number">0</span>][len<span class="hljs-number">-1</span>];
    }
};
</div></code></pre>
<h2 id="813">8.13</h2>
<h3 id="143重排链表">143.重排链表</h3>
<p><a href="">重排链表</a></p>
<pre><code class="language-c++"><div><span class="hljs-comment">//Definition for singly-linked list.</span>
<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ListNode</span> {</span>
    <span class="hljs-keyword">int</span> val;
    ListNode *next;
    ListNode() : val(<span class="hljs-number">0</span>), next(<span class="hljs-literal">nullptr</span>) {}
    ListNode(<span class="hljs-keyword">int</span> x) : val(x), next(<span class="hljs-literal">nullptr</span>) {}
    ListNode(<span class="hljs-keyword">int</span> x, ListNode *next) : val(x), next(next) {}
};

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> {</span>
<span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">reorderList</span><span class="hljs-params">(ListNode* head)</span> </span>{
        <span class="hljs-built_in">vector</span>&lt;ListNode*&gt; temp;
        ListNode* cur = head;
        <span class="hljs-keyword">while</span>(cur!=<span class="hljs-literal">nullptr</span>)
        {
            temp.emplace_back(cur);
            cur = cur-&gt;next;
        }
        <span class="hljs-keyword">int</span> l = <span class="hljs-number">0</span>,r = temp.size() - <span class="hljs-number">1</span>;
        <span class="hljs-keyword">while</span>(l&lt;r)
        {
            temp[l]-&gt;next = temp[r];
            l++;
            <span class="hljs-keyword">if</span>(l==r)<span class="hljs-keyword">break</span>;
            temp[r]-&gt;next = temp[l];
            r--;
        }
        temp[l]-&gt;next = <span class="hljs-literal">nullptr</span>;<span class="hljs-comment">//关键 不然会形成环</span>
        <span class="hljs-keyword">return</span>;
    }
};
</div></code></pre>
<h2 id="815">8.15</h2>
<h3 id="576出界的路径数">576.出界的路径数</h3>
<p><a href="">出界的路径数</a></p>
<pre><code class="language-c++"><div><span class="hljs-comment">//不能递归 递归一定栈溢出</span>
<span class="hljs-comment">//动态规划 dp[i][j][k] 表示移动i次后到达(j,k)的路径数</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> {</span>
<span class="hljs-keyword">public</span>: 
    <span class="hljs-keyword">static</span> <span class="hljs-keyword">constexpr</span> <span class="hljs-keyword">int</span> MOD = <span class="hljs-number">1&#x27;000&#x27;000&#x27;007</span>;
    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">findPaths</span><span class="hljs-params">(<span class="hljs-keyword">int</span> m, <span class="hljs-keyword">int</span> n, <span class="hljs-keyword">int</span> maxMove, <span class="hljs-keyword">int</span> startRow, <span class="hljs-keyword">int</span> startColumn)</span> </span>{
        <span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&gt; dir{{<span class="hljs-number">0</span>,<span class="hljs-number">1</span>},{<span class="hljs-number">1</span>,<span class="hljs-number">0</span>},{<span class="hljs-number">0</span>,<span class="hljs-number">-1</span>},{<span class="hljs-number">-1</span>,<span class="hljs-number">0</span>}};
        <span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&gt;&gt; <span class="hljs-title">dp</span><span class="hljs-params">(maxMove+<span class="hljs-number">1</span>,<span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&gt;(m,<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;(n)))</span></span>;
        <span class="hljs-keyword">int</span> outputs = <span class="hljs-number">0</span>;
        dp[<span class="hljs-number">0</span>][startRow][startColumn] = <span class="hljs-number">1</span>;
        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i &lt; maxMove;i++)
        {
            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>;j &lt; m;j++)
            {
                <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> k = <span class="hljs-number">0</span>;k &lt; n;k++)
                {
                    <span class="hljs-keyword">int</span> count = dp[i][j][k];
                    <span class="hljs-keyword">if</span>(count &gt; <span class="hljs-number">0</span>)
                    {
                        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> &amp;d:dir)
                        {
                            <span class="hljs-keyword">int</span> j1 = j + d[<span class="hljs-number">0</span>];
                            <span class="hljs-keyword">int</span> k1 = k + d[<span class="hljs-number">1</span>];
                            <span class="hljs-keyword">if</span>(j1 &gt;= <span class="hljs-number">0</span> &amp;&amp; j1 &lt; m &amp;&amp; k1 &gt;= <span class="hljs-number">0</span> &amp;&amp; k1 &lt; n)
                            {
                                dp[i+<span class="hljs-number">1</span>][j1][k1] = (dp[i+<span class="hljs-number">1</span>][j1][k1] + count) % MOD;
                            }
                            <span class="hljs-keyword">else</span>
                            {
                                outputs = (outputs + count)%MOD;
                            }
                        }
                    }
                }
            }
        }
        <span class="hljs-keyword">return</span> outputs;
        
    }
};
</div></code></pre>
<h2 id="818">8.18</h2>
<h3 id="剑指offer09用两个栈实现队列">剑指offer09.用两个栈实现队列</h3>
<p><a href="">剑指offer09.用两个栈实现队列</a></p>
<pre><code class="language-c++"><div><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CQueue</span> {</span>
<span class="hljs-keyword">public</span>:
    <span class="hljs-built_in">stack</span>&lt;<span class="hljs-keyword">int</span>&gt; inStack;
    <span class="hljs-built_in">stack</span>&lt;<span class="hljs-keyword">int</span>&gt; outStack;
    CQueue() {
        
    }
    
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">appendTail</span><span class="hljs-params">(<span class="hljs-keyword">int</span> value)</span> </span>{
        inStack.push(value);
    }
    
    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">deleteHead</span><span class="hljs-params">()</span> </span>{
        <span class="hljs-keyword">if</span>(outStack.empty())
        {
            <span class="hljs-keyword">while</span>(!inStack.empty())
            {
                <span class="hljs-keyword">int</span> num = inStack.top();
                outStack.push(num);
                inStack.pop();
            }
        }
       
        <span class="hljs-keyword">if</span>(outStack.empty())
        {
            <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;
        }
        <span class="hljs-keyword">else</span>
        {
            <span class="hljs-keyword">int</span> num = outStack.top();
            outStack.pop();
            <span class="hljs-keyword">return</span> num;
        }
    }
};
</div></code></pre>
<h3 id="剑指offer30包含min函数的栈">剑指offer30.包含min函数的栈</h3>
<p><a href="">剑指offer30.包含min函数的栈</a></p>
<pre><code class="language-c++"><div><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MinStack</span> {</span>
<span class="hljs-keyword">public</span>:
    <span class="hljs-comment">/** initialize your data structure here. */</span>
    <span class="hljs-built_in">stack</span>&lt;<span class="hljs-keyword">int</span>&gt; myStack;
    <span class="hljs-built_in">stack</span>&lt;<span class="hljs-keyword">int</span>&gt; sup;
    MinStack() {
    
    }
    
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">push</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span> </span>{
        myStack.push(x);
        <span class="hljs-keyword">if</span>(!sup.empty())
        {
            <span class="hljs-keyword">int</span> num = sup.top();
            <span class="hljs-keyword">if</span>(x &lt;= num)
            {
                sup.push(x);
            }
        }
        <span class="hljs-keyword">else</span>
        {
            sup.push(x);
        }
    }
    
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">pop</span><span class="hljs-params">()</span> </span>{
        <span class="hljs-keyword">int</span> num  = myStack.top();
        <span class="hljs-keyword">if</span>(num == sup.top())sup.pop();
        myStack.pop();
    }
    
    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">top</span><span class="hljs-params">()</span> </span>{
        <span class="hljs-keyword">return</span> myStack.top();
    }
    
    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">min</span><span class="hljs-params">()</span> </span>{
        <span class="hljs-keyword">return</span> sup.top();
    }
};

</div></code></pre>
<h2 id="819">8.19</h2>
<h3 id="345反转字符串中的元音字母">345.反转字符串中的元音字母</h3>
<p><a href="">345.反转字符串中的元音字母</a></p>
<pre><code class="language-c++"><div><span class="hljs-comment">//双指针</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> {</span>
<span class="hljs-keyword">public</span>:
    <span class="hljs-built_in">unordered_set</span>&lt;<span class="hljs-keyword">char</span>&gt; mySet{<span class="hljs-string">&#x27;a&#x27;</span>,<span class="hljs-string">&#x27;e&#x27;</span>,<span class="hljs-string">&#x27;i&#x27;</span>,<span class="hljs-string">&#x27;o&#x27;</span>,<span class="hljs-string">&#x27;u&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;E&#x27;</span>,<span class="hljs-string">&#x27;I&#x27;</span>,<span class="hljs-string">&#x27;O&#x27;</span>,<span class="hljs-string">&#x27;U&#x27;</span>};
    <span class="hljs-function"><span class="hljs-built_in">string</span> <span class="hljs-title">reverseVowels</span><span class="hljs-params">(<span class="hljs-built_in">string</span> s)</span> </span>{
        <span class="hljs-keyword">int</span> l = <span class="hljs-number">0</span>;
        <span class="hljs-keyword">int</span> r = s.size() - <span class="hljs-number">1</span>;
        <span class="hljs-keyword">while</span>(l&lt;r)
        {
            <span class="hljs-keyword">char</span> lc = s.at(l);
            <span class="hljs-keyword">char</span> rc = s.at(r);
            <span class="hljs-keyword">if</span>(mySet.find(lc) != mySet.end())
            {
                <span class="hljs-keyword">if</span>(mySet.find(rc) != mySet.end())
                {
                    s[l] = rc;
                    s[r] = lc;
                    l++;
                    r--;
                }
                <span class="hljs-keyword">else</span>
                {
                    r--;
                }
            }
            <span class="hljs-keyword">else</span>
            {
                l++;
            }
        }
        <span class="hljs-keyword">return</span> s;
    }
};
</div></code></pre>
<h3 id="剑指offer06从尾到头打印链表">剑指offer06.从尾到头打印链表</h3>
<p><a href="">剑指offer06.从尾到头打印链表</a></p>
<pre><code class="language-c++"><div><span class="hljs-comment">//递归 也等同于用栈</span>
<span class="hljs-comment">//Definition for singly-linked list.</span>
<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ListNode</span> {</span>
    <span class="hljs-keyword">int</span> val;
    ListNode *next;
    ListNode(<span class="hljs-keyword">int</span> x) : val(x), next(<span class="hljs-literal">NULL</span>) {}
};

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> {</span>
<span class="hljs-keyword">public</span>:
    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; ans;
    <span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">reversePrint</span><span class="hljs-params">(ListNode* head)</span> </span>{
        <span class="hljs-keyword">if</span>(head!=<span class="hljs-literal">nullptr</span>)
        {
            reversePutIn(head);
        }
        <span class="hljs-keyword">return</span> ans;
    }
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">reversePutIn</span><span class="hljs-params">(ListNode* node)</span>
    </span>{
        <span class="hljs-keyword">if</span>(node-&gt;next == <span class="hljs-literal">nullptr</span>)
        {
            ans.push_back(node-&gt;val);
            <span class="hljs-keyword">return</span>;
        }
        <span class="hljs-keyword">else</span>
        {
            reversePutIn(node-&gt;next);
            ans.push_back(node-&gt;val);
        }
    }
};
</div></code></pre>
<h3 id="剑指offer24反转链表">剑指offer24.反转链表</h3>
<p><a href="">剑指offer24.反转链表</a></p>
<pre><code class="language-c++"><div><span class="hljs-comment">//递归</span>
<span class="hljs-comment">//Definition for singly-linked list.</span>
<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ListNode</span> {</span>
    <span class="hljs-keyword">int</span> val;
    ListNode *next;
    ListNode(<span class="hljs-keyword">int</span> x) : val(x), next(<span class="hljs-literal">NULL</span>) {}
};

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> {</span>
<span class="hljs-keyword">public</span>:
<span class="hljs-comment">//递归</span>
    <span class="hljs-function">ListNode* <span class="hljs-title">reverseList</span><span class="hljs-params">(ListNode* head)</span> </span>{
        <span class="hljs-keyword">if</span>(!head || !head-&gt;next)
        {
            <span class="hljs-keyword">return</span> head;
        }
        <span class="hljs-keyword">else</span>
        {
            ListNode *newHead = reverseList(head-&gt;next);
            head-&gt;next-&gt;next = head;
            head-&gt;next = <span class="hljs-literal">nullptr</span>;
            <span class="hljs-keyword">return</span> newHead;
        }
    }
<span class="hljs-comment">//迭代</span>
    <span class="hljs-function">ListNode* <span class="hljs-title">reverseList</span><span class="hljs-params">(ListNode* head)</span> </span>{
        ListNode* pre = <span class="hljs-literal">nullptr</span>;
        ListNode* cur = head;
        <span class="hljs-keyword">while</span>(cur)
        {
            ListNode* next = cur-&gt;next;
            cur-&gt;next = pre;
            pre = cur;
            cur = next;
        }
        <span class="hljs-keyword">return</span> pre;
    }
};
</div></code></pre>
<h2 id="820">8.20</h2>
<h3 id="541反转字符串2">541.反转字符串2</h3>
<p><a href="">541.反转字符串2</a></p>
<pre><code class="language-c++"><div><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> {</span>
<span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-built_in">string</span> <span class="hljs-title">reverseStr</span><span class="hljs-params">(<span class="hljs-built_in">string</span> s, <span class="hljs-keyword">int</span> k)</span> </span>{
        <span class="hljs-keyword">int</span> len = s.size();
        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i &lt; len;i+=<span class="hljs-number">2</span>*k)
        {
            reverse(s.begin() + i, s.begin() + min(i+k,len));<span class="hljs-comment">//剩余字符少于k个的情况</span>
        }
        <span class="hljs-keyword">return</span> s;
    }
};
</div></code></pre>
<h3 id="剑指offer05替换空格">剑指offer05.替换空格</h3>
<p><a href="">剑指offer05.替换空格</a></p>
<pre><code class="language-c++"><div><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> {</span>
<span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-built_in">string</span> <span class="hljs-title">replaceSpace</span><span class="hljs-params">(<span class="hljs-built_in">string</span> s)</span> </span>{
        <span class="hljs-built_in">string</span> ans;
        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">char</span> ch:s)
        {
            <span class="hljs-keyword">if</span>(ch == <span class="hljs-string">&#x27; &#x27;</span>)
            {
                ans.push_back(<span class="hljs-string">&#x27;%&#x27;</span>);
                ans.push_back(<span class="hljs-string">&#x27;2&#x27;</span>);
                ans.push_back(<span class="hljs-string">&#x27;0&#x27;</span>);
            }
            <span class="hljs-keyword">else</span>
            {
                ans.push_back(ch);
            }
        }
        <span class="hljs-keyword">return</span> ans;
    }
};
</div></code></pre>
<h3 id="剑指offer35复杂链表的复制">剑指offer35.复杂链表的复制</h3>
<p><a href="">剑指offer35.复杂链表的复制</a></p>
<pre><code class="language-c++"><div><span class="hljs-comment">// Definition for a Node.</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Node</span> {</span>
<span class="hljs-keyword">public</span>:
    <span class="hljs-keyword">int</span> val;
    Node* next;
    Node* random;
    
    Node(<span class="hljs-keyword">int</span> _val) {
        val = _val;
        next = <span class="hljs-literal">NULL</span>;
        random = <span class="hljs-literal">NULL</span>;
    }
};
<span class="hljs-comment">//递归</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> {</span>
<span class="hljs-keyword">public</span>:
    <span class="hljs-built_in">map</span>&lt;Node*,Node*&gt; myMap;
    <span class="hljs-function">Node* <span class="hljs-title">copyRandomList</span><span class="hljs-params">(Node* head)</span> </span>{
        <span class="hljs-keyword">if</span>(!head)<span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;
        <span class="hljs-keyword">if</span>(!myMap.count(head))
        {
            <span class="hljs-comment">//还未复制过该节点</span>
            Node * newHead = <span class="hljs-keyword">new</span> Node(head-&gt;val);
            myMap[head] = newHead;
            newHead-&gt;next = copyRandomList(head-&gt;next);
            newHead-&gt;random = copyRandomList(head-&gt;random);
        }
        <span class="hljs-keyword">return</span> myMap[head];
    }
};
</div></code></pre>
<h3 id="剑指offer58-二左旋转字符串">剑指offer58-二.左旋转字符串</h3>
<p><a href="">剑指offer58-二.左旋转字符串</a></p>
<pre><code class="language-c++"><div><span class="hljs-comment">//string类方法</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> {</span>
<span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-built_in">string</span> <span class="hljs-title">reverseLeftWords</span><span class="hljs-params">(<span class="hljs-built_in">string</span> s, <span class="hljs-keyword">int</span> n)</span> </span>{
        <span class="hljs-built_in">string</span> temp = s.substr(<span class="hljs-number">0</span>,n);
        s.erase(<span class="hljs-number">0</span>,n);
        s.append(temp);
        <span class="hljs-keyword">return</span> s;
    }
};
</div></code></pre>
<h2 id="821">8.21</h2>
<h3 id="443压缩字符串">443.压缩字符串</h3>
<p><a href="">443.压缩字符串</a></p>
<pre><code class="language-c++"><div><span class="hljs-comment">//由于是原地算法 常量额外空间</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> {</span>
<span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">compress</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">char</span>&gt;&amp; chars)</span> </span>{
        <span class="hljs-keyword">if</span>(chars.size()==<span class="hljs-number">1</span>)<span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;
        <span class="hljs-keyword">int</span> write = <span class="hljs-number">0</span>,read = <span class="hljs-number">0</span>,left = <span class="hljs-number">0</span>;
        <span class="hljs-keyword">for</span>(read = <span class="hljs-number">0</span>;read &lt; chars.size();read++)
        {
            <span class="hljs-keyword">if</span>(read == chars.size()<span class="hljs-number">-1</span> || chars[read + <span class="hljs-number">1</span>] != chars[read]) 
            {
                chars[write++] = chars[read];
                <span class="hljs-keyword">int</span> cnt = read - left + <span class="hljs-number">1</span>;
                <span class="hljs-keyword">int</span> temp = write;
                <span class="hljs-keyword">if</span>(cnt &gt; <span class="hljs-number">1</span>)
                {
                    <span class="hljs-keyword">while</span>(cnt)
                    {
                        chars[write++] = cnt%<span class="hljs-number">10</span> + <span class="hljs-string">&#x27;0&#x27;</span>;
                        cnt/=<span class="hljs-number">10</span>;
                    }
                    <span class="hljs-comment">//reverse函数 前闭后开 即不包括最后一个元素</span>
                    reverse(&amp;chars[temp],&amp;chars[write]);
                }
                left = read + <span class="hljs-number">1</span>;
            }
        }
        chars.erase(chars.begin()+write,chars.end());
        <span class="hljs-keyword">return</span> chars.size();
    }
};
</div></code></pre>
<h2 id="822">8.22</h2>
<h3 id="789逃脱阻碍者">789.逃脱阻碍者</h3>
<p><a href="">789.逃脱阻碍者</a></p>
<pre><code class="language-c++"><div><span class="hljs-comment">//数学 曼哈顿距离 |xt-x|+|yt-y|</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> {</span>
<span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">escapeGhosts</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&gt;&amp; ghosts, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; target)</span> </span>{
        <span class="hljs-keyword">int</span> xt = target[<span class="hljs-number">0</span>],yt = target[<span class="hljs-number">1</span>];
        <span class="hljs-keyword">int</span> myDistance = <span class="hljs-built_in">abs</span>(xt) + <span class="hljs-built_in">abs</span>(yt);
        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i &lt; ghosts.size();i++)
        {
            <span class="hljs-keyword">int</span> gxt = <span class="hljs-built_in">abs</span>(ghosts[i][<span class="hljs-number">0</span>] - xt);
            <span class="hljs-keyword">int</span> gyt = <span class="hljs-built_in">abs</span>(ghosts[i][<span class="hljs-number">1</span>] - yt);
            <span class="hljs-keyword">int</span> gDistance = gxt + gyt;
            <span class="hljs-keyword">if</span>(gDistance &lt;= myDistance)<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
        }
        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
    }
};
</div></code></pre>
<h3 id="剑指offer03数组中重复的数字">剑指offer03.数组中重复的数字</h3>
<p><a href="">剑指offer03.数组中重复的数字</a></p>
<pre><code class="language-c++"><div><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> {</span>
<span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">findRepeatNumber</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums)</span> </span>{
        sort(nums.begin(),nums.end());
        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;nums.size();i++)
        {
            <span class="hljs-keyword">if</span>(nums[i] == nums[i<span class="hljs-number">-1</span>])<span class="hljs-keyword">return</span> nums[i];
        }
        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
    }
};
</div></code></pre>
<h3 id="剑指offer04二维数组中的查找">剑指offer04.二维数组中的查找</h3>
<p><a href="">剑指offer04.二维数组中的查找</a></p>
<pre><code class="language-c++"><div><span class="hljs-comment">//从右下角开始查找</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> {</span>
<span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">findNumberIn2DArray</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&gt;&amp; matrix, <span class="hljs-keyword">int</span> target)</span> </span>{
        <span class="hljs-keyword">if</span>(matrix.size() == <span class="hljs-number">0</span>)<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
        <span class="hljs-keyword">int</span> row = matrix.size(),col = matrix[<span class="hljs-number">0</span>].size();
        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> r = row - <span class="hljs-number">1</span>;r &gt;= <span class="hljs-number">0</span>;r--)
        {
            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> c = <span class="hljs-number">0</span>;c &lt; col;c++)
            {
                <span class="hljs-keyword">if</span>(target == matrix[r][c])<span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
                <span class="hljs-keyword">if</span>(target &lt; matrix[r][c])
                {
                    <span class="hljs-keyword">break</span>;
                }
            }
        }
        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
    }
};
</div></code></pre>
<h3 id="剑指offer11旋转数组的最小数字">剑指offer11.旋转数组的最小数字</h3>
<p><a href="">剑指offer11.旋转数组的最小数字</a></p>
<pre><code class="language-c++"><div><span class="hljs-comment">//二分查找</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> {</span>
<span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">minArray</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; numbers)</span> </span>{
       <span class="hljs-keyword">int</span> left = <span class="hljs-number">0</span>, right = numbers.size() - <span class="hljs-number">1</span>;
       <span class="hljs-keyword">while</span>(left &lt;= right)
       {
           <span class="hljs-keyword">int</span> mid = left + (right-left)/<span class="hljs-number">2</span>;
           <span class="hljs-keyword">if</span>(numbers[mid] &lt; numbers[right])
           {
               right = mid - <span class="hljs-number">1</span>
           }
           <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(numbers[mid] &gt;  numbers[right])
           {
               left = mid + <span class="hljs-number">1</span>;
           }
           <span class="hljs-keyword">else</span>
           {
               right = mid;
           }
       }
       <span class="hljs-keyword">return</span> numbers[left];
    }
};
</div></code></pre>
<h3 id="剑指offer53-i在排序数组中查找数字i">剑指offer53-I.在排序数组中查找数字I</h3>
<p><a href="">剑指offer53-I.在排序数组中查找数字I</a></p>
<pre><code class="language-c++"><div><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> {</span>
<span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">binarySearch</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums, <span class="hljs-keyword">int</span> target, <span class="hljs-keyword">bool</span> lower)</span>
    </span>{
        <span class="hljs-keyword">int</span> left = <span class="hljs-number">0</span>,right = (<span class="hljs-keyword">int</span>)nums.size()<span class="hljs-number">-1</span>,ans = (<span class="hljs-keyword">int</span>)nums.size();
        <span class="hljs-keyword">while</span>(left &lt;= right)
        {
            <span class="hljs-keyword">int</span> mid = (left + right)/<span class="hljs-number">2</span>;
            <span class="hljs-keyword">if</span>(nums[mid] &gt; target || (lower &amp;&amp; nums[mid] &gt;= target))
            {
                right = mid - <span class="hljs-number">1</span>;
                ans = mid;
            }
            <span class="hljs-keyword">else</span>
            {
                left = mid + <span class="hljs-number">1</span>;
            }
        }
        <span class="hljs-keyword">return</span> ans;
    }
    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">search</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums, <span class="hljs-keyword">int</span> target)</span> </span>{
        <span class="hljs-comment">//普通查找On</span>
        <span class="hljs-comment">// int cnt = 0;</span>
        <span class="hljs-comment">// for(int i = 0;i &lt; nums.size();i++)</span>
        <span class="hljs-comment">// {</span>
        <span class="hljs-comment">//     if(nums[i] &gt; target)return cnt;</span>
        <span class="hljs-comment">//     if(nums[i] == target)</span>
        <span class="hljs-comment">//     {</span>
        <span class="hljs-comment">//         cnt++;</span>
        <span class="hljs-comment">//     }</span>
        <span class="hljs-comment">// }</span>
        <span class="hljs-comment">// return cnt;</span>
        <span class="hljs-comment">//二分查找Ologn</span>
        <span class="hljs-keyword">if</span>(nums.size() == <span class="hljs-number">0</span>)<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
        <span class="hljs-keyword">int</span> left = binarySearch(nums,target,<span class="hljs-literal">true</span>);
        <span class="hljs-keyword">int</span> right = binarySearch(nums,target,<span class="hljs-literal">false</span>) - <span class="hljs-number">1</span>;
        <span class="hljs-keyword">if</span>(left &lt;= right &amp;&amp; left &gt;= <span class="hljs-number">0</span> &amp;&amp; right &lt; nums.size() &amp;&amp; nums[left] == target &amp;&amp; nums[right] == target)
        {
            <span class="hljs-keyword">return</span> right - left + <span class="hljs-number">1</span>;
        }
        <span class="hljs-keyword">else</span>
        {
            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
        }
    }
};
</div></code></pre>
<h3 id="剑指offer53-ⅱ0n-1中缺失的数字">剑指offer53-Ⅱ.0~n-1中缺失的数字</h3>
<p><a href="">剑指offer53-Ⅱ.0~n-1中缺失的数字</a></p>
<pre><code class="language-c++"><div><span class="hljs-comment">//二分法</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> {</span>
<span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">missingNumber</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums)</span> </span>{
       <span class="hljs-keyword">int</span> left = <span class="hljs-number">0</span>,right = nums.size() - <span class="hljs-number">1</span>;
       <span class="hljs-keyword">while</span>(left&lt;=right)
       {
           <span class="hljs-keyword">int</span> mid = (left+right)/<span class="hljs-number">2</span>;
           <span class="hljs-keyword">if</span>(nums[mid] == mid)
           {
               left = mid + <span class="hljs-number">1</span>;
           }
           <span class="hljs-keyword">else</span>
           {
               right = mid - <span class="hljs-number">1</span>;
           }
       }
       <span class="hljs-keyword">return</span> left;
    }
};
</div></code></pre>

    </body>
    </html>